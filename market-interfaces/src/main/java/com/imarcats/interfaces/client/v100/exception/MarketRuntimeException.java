package com.imarcats.interfaces.client.v100.exception;

import com.imarcats.interfaces.client.v100.messages.response.ExceptionMessage;
import com.imarcats.interfaces.client.v100.messages.response.ExceptionMessageType;

@SuppressWarnings("serial")
public class MarketRuntimeException extends MarketExceptionBase {

	// Order State Errors
	public static final MarketRuntimeException ORDER_ALREADY_SUBMITTED = new MarketRuntimeException(ExceptionLanguageKeys.ORDER_ALREADY_SUBMITTED, ExceptionType.IllegalStateException, "Order has already been submitted");
	public static final MarketRuntimeException EXECUTED_ORDER_CANNOT_BE_RESUBMITTED = new MarketRuntimeException(ExceptionLanguageKeys.EXECUTED_ORDER_CANNOT_BE_RESUBMITTED, ExceptionType.IllegalStateException, "Executed Order cannot be re-submitted");
	public static final MarketRuntimeException ORDER_HAS_ALREADY_BEEN_CANCELED = new MarketRuntimeException(ExceptionLanguageKeys.ORDER_HAS_ALREADY_BEEN_CANCELED, ExceptionType.IllegalStateException, "Order has already been canceled");
	public static final MarketRuntimeException EXECUTED_ORDER_CANNOT_BE_CANCELLED = new MarketRuntimeException(ExceptionLanguageKeys.EXECUTED_ORDER_CANNOT_BE_CANCELED, ExceptionType.IllegalStateException, "Executed Order cannot be canceled");
	public static final MarketRuntimeException SUBMITTED_ORDER_CANNOT_BE_DELETED_CANCEL_FIRST = new MarketRuntimeException(ExceptionLanguageKeys.SUBMITTED_ORDER_CANNOT_BE_DELETED_CANCEL_FIRST, ExceptionType.IllegalStateException, "Submitted Order cannot be deleted, cancel it first");

	// Order Handling Errors
	public static final MarketRuntimeException ORDER_SIZE_CANNOT_BE_ZERO = new MarketRuntimeException(ExceptionLanguageKeys.ORDER_SIZE_CANNOT_BE_ZERO, ExceptionType.IllegalArgumentException, "Order size cannot be zero");
	public static final MarketRuntimeException ORDER_IS_TOO_BIG_FOR_THE_MARKET = new MarketRuntimeException(ExceptionLanguageKeys.ORDER_IS_TOO_BIG_FOR_THE_MARKET, ExceptionType.IllegalArgumentException, "Order is to big for this Market");
	public static final MarketRuntimeException ORDER_IS_TOO_SMALL_FOR_THE_MARKET = new MarketRuntimeException(ExceptionLanguageKeys.ORDER_IS_TOO_SMALL_FOR_THE_MARKET, ExceptionType.IllegalArgumentException, "Order is to small for this Market");
	public static final MarketRuntimeException ORDER_SIDE_CANNOT_BE_IDENTIFIED = new MarketRuntimeException(ExceptionLanguageKeys.ORDER_SIDE_CANNOT_BE_IDENTIFIED, ExceptionType.IllegalArgumentException, "Order side cannot be identified");
	public static final MarketRuntimeException ORDER_TYPE_CANNOT_BE_IDENTIFIED = new MarketRuntimeException(ExceptionLanguageKeys.ORDER_TYPE_CANNOT_BE_IDENTIFIED, ExceptionType.IllegalArgumentException, "Order type cannot be identified");
	public static final MarketRuntimeException ORDER_CANNOT_BE_SUBMITTED_TO_NON_ACTIVE_MARKET = new MarketRuntimeException(ExceptionLanguageKeys.ORDER_CANNOT_BE_SUBMITTED_TO_NON_ACTIVE_MARKET, ExceptionType.IllegalStateException, "Order cannot be submitted to a non-active market");
	public static final MarketRuntimeException ORDER_SIZE_IS_SMALLER_THAN_MINIMUM_SIZE_OF_EXECUTION = new MarketRuntimeException(ExceptionLanguageKeys.ORDER_SIZE_IS_SMALLER_THAN_MINIMUM_SIZE_OF_EXECUTION, ExceptionType.IllegalArgumentException, "Order has a smaller size than the minimum size needs to be executed from the Order");
	public static final MarketRuntimeException ORDER_SHOULD_HAVE_MINIMUM_SIZE_OF_EXECUTION_OR_ENTIRE_AT_ONCE_SET = new MarketRuntimeException(ExceptionLanguageKeys.ORDER_SHOULD_HAVE_MINIMUM_SIZE_OF_EXECUTION_OR_ENTIRE_AT_ONCE_SET, ExceptionType.IllegalArgumentException, "Order should either have Minimum Size of Execution or Entire Order at Once set.");
	public static final MarketRuntimeException IMMEDIATE_OR_CANCEL_ORDER_IS_NOT_SUPPORTED_ON_CALL_MARKET = new MarketRuntimeException(ExceptionLanguageKeys.IMMEDIATE_OR_CANCEL_ORDER_IS_NOT_SUPPORTED_ON_CALL_MARKET, ExceptionType.IllegalArgumentException, "ImmediateOrCancel Order is not supported on Call Markets");
	public static final MarketRuntimeException IMMEDIATE_OR_CANCEL_ORDER_IS_NOT_SUPPORTED_WHEN_THE_MARKET_IS_NOT_OPEN = new MarketRuntimeException(ExceptionLanguageKeys.IMMEDIATE_OR_CANCEL_ORDER_IS_NOT_SUPPORTED_WHEN_THE_MARKET_IS_NOT_OPEN, ExceptionType.IllegalArgumentException, "ImmediateOrCancel Order is not supported when the Market is not Open");
	public static final MarketRuntimeException MARKET_ORDER_IS_NOT_SUPPORTED_WHEN_THE_MARKET_IS_NOT_OPEN = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_ORDER_IS_NOT_SUPPORTED_WHEN_THE_MARKET_IS_NOT_OPEN, ExceptionType.IllegalArgumentException, "Market Order is not supported when the Market is not Open");
	public static final MarketRuntimeException MARKET_ORDER_IS_NOT_SUPPORTED_ON_CALL_MARKET = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_ORDER_IS_NOT_SUPPORTED_ON_CALL_MARKET, ExceptionType.IllegalArgumentException, "Market Order is not supported on Call Markets");
	public static final MarketRuntimeException ONLY_GOOD_TILL_CANCEL_ORDER_IS_SUPPORTED_ON_CALL_MARKET = new MarketRuntimeException(ExceptionLanguageKeys.ONLY_GOOD_TILL_CANCEL_ORDER_IS_SUPPORTED_ON_CALL_MARKET, ExceptionType.IllegalArgumentException, "Only Good-till-Cancel Order is supported on Call Markets");
	public static final MarketRuntimeException ONLY_IMMEDIATELY_TRIGGERED_ORDER_IS_SUPPORTED_ON_CALL_MARKET = new MarketRuntimeException(ExceptionLanguageKeys.ONLY_IMMEDIATELY_TRIGGERED_ORDER_IS_SUPPORTED_ON_CALL_MARKET, ExceptionType.IllegalArgumentException, "Only Immediately Triggered Order is supported on Call Markets");
	public static final MarketRuntimeException MARKET_ORDER_MUST_BE_IMMEDIATE_OR_CANCEL = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_ORDER_MUST_BE_IMMEDIATE_OR_CANCEL, ExceptionType.IllegalArgumentException, "Market Order must be defined to be Immediate-or-Cancel");
	public static final MarketRuntimeException HIDDEN_ORDER_NOT_SUPPORTED_ON_MARKET = new MarketRuntimeException(ExceptionLanguageKeys.HIDDEN_ORDER_NOT_SUPPORTED_ON_MARKET, ExceptionType.IllegalArgumentException, "Hidden Order is Not Supported on this Market");
	public static final MarketRuntimeException SIZE_RESTRICTION_ON_ORDER_NOT_SUPPORTED_ON_MARKET = new MarketRuntimeException(ExceptionLanguageKeys.SIZE_RESTRICTION_ON_ORDER_NOT_SUPPORTED_ON_MARKET, ExceptionType.IllegalArgumentException, "Size Restriction on Order is Not Supported on this Market");
	public static final MarketRuntimeException MARKET_ORDER_SUBMITTED_CANNOT_BE_FILLED_ON_CALL_MARKET = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_ORDER_SUBMITTED_CANNOT_BE_FILLED_ON_CALL_MARKET, ExceptionType.IllegalArgumentException, "Market Order submitted makes the size of Standing Market Order the same on a Call Markets");	
	public static final MarketRuntimeException ENTIRE_ORDER_AT_ONCE_NOT_SUPPORTED_ON_CALL_MARKET = new MarketRuntimeException(ExceptionLanguageKeys.ENTIRE_ORDER_AT_ONCE_NOT_SUPPORTED_ON_CALL_MARKET, ExceptionType.IllegalArgumentException, "Entire-Order-at-Once is Not Supported on Call Market");	
	public static final MarketRuntimeException MINIMUM_EXECUTION_SIZE_NOT_SUPPORTED_ON_CALL_MARKET = new MarketRuntimeException(ExceptionLanguageKeys.MINIMUM_EXECUTION_SIZE_NOT_SUPPORTED_ON_CALL_MARKET, ExceptionType.IllegalArgumentException, "Minimum Execution Size is Not Supported on Call Market");
	public static final MarketRuntimeException ENTIRE_ORDER_AT_ONCE_NOT_SUPPORTED_WHEN_THE_MARKET_IS_NOT_OPEN = new MarketRuntimeException(ExceptionLanguageKeys.ENTIRE_ORDER_AT_ONCE_NOT_SUPPORTED_WHEN_THE_MARKET_IS_NOT_OPEN, ExceptionType.IllegalArgumentException, "Entire-Order-at-Once is Not Supported, when the Market is Not Open");	
	public static final MarketRuntimeException MINIMUM_EXECUTION_SIZE_NOT_SUPPORTED_WHEN_THE_MARKET_IS_NOT_OPEN = new MarketRuntimeException(ExceptionLanguageKeys.MINIMUM_EXECUTION_SIZE_NOT_SUPPORTED_WHEN_THE_MARKET_IS_NOT_OPEN, ExceptionType.IllegalArgumentException, "Minimum Execution Size is Not Supported, when the Market is Not Open");	
	public static final MarketRuntimeException MARKET_ORDER_CANNOT_BE_SUBMITTED_IF_THE_OTHER_SIDE_BOOK_IS_EMPTY = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_ORDER_CANNOT_BE_SUBMITTED_IF_THE_OTHER_SIDE_BOOK_IS_EMPTY, ExceptionType.IllegalArgumentException, "Market Order cannot be submitted, because the Other Side Order Book is Empty");
	public static final MarketRuntimeException MARKET_ORDER_CANNOT_BE_SUBMITTED_IF_THE_OTHER_SIDE_BOOK_HAS_ONLY_MARKET_ORDERS = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_ORDER_CANNOT_BE_SUBMITTED_IF_THE_OTHER_SIDE_BOOK_HAS_ONLY_MARKET_ORDERS, ExceptionType.IllegalArgumentException, "Market Order cannot be submitted, because the Other Side Order Book only Market Orders");
	public static final MarketRuntimeException ORDER_MUST_BE_SUBMITTED_WITH_A_VALID_MARKET_QUOTE = new MarketRuntimeException(ExceptionLanguageKeys.ORDER_MUST_BE_SUBMITTED_WITH_A_VALID_MARKET_QUOTE, ExceptionType.IllegalArgumentException, "Order must either be submitted on an existing Quote or move the Market at least with the Minimum Quote Increment");
	public static final MarketRuntimeException ORDER_IMPROVES_QUOTE_WITH_MORE_THAN_MAXIMUM_QUOTE_IMPROVEMENT = new MarketRuntimeException(ExceptionLanguageKeys.ORDER_IMPROVES_QUOTE_WITH_MORE_THAN_MAXIMUM_QUOTE_IMPROVEMENT, ExceptionType.IllegalArgumentException, "Order improves the Quote (from Last Trade) with more than the Maximum Quote Improvement");
	public static final MarketRuntimeException STOP_QUOTE_IS_NOT_DEFINED_ON_STOP_ORDER = new MarketRuntimeException(ExceptionLanguageKeys.STOP_QUOTE_IS_NOT_DEFINED_ON_STOP_ORDER, ExceptionType.IllegalArgumentException, "Stop Quote is not defined on Stop Order");	
	public static final MarketRuntimeException STOP_QUOTE_DIFFERENCE_IS_NOT_DEFINED_ON_STOP_ORDER = new MarketRuntimeException(ExceptionLanguageKeys.STOP_QUOTE_DIFFERENCE_IS_NOT_DEFINED_ON_STOP_ORDER, ExceptionType.IllegalArgumentException, "Stop Quote Difference is not defined on Stop Order");	
	public static final MarketRuntimeException UNSUPPORTED_QUOTE_CHANGE_TRIGGER = new MarketRuntimeException(ExceptionLanguageKeys.UNSUPPORTED_QUOTE_CHANGE_TRIGGER, ExceptionType.IllegalArgumentException, "Quote Change Trigger defined on the Order is not supported");
	public static final MarketRuntimeException UNSUPPORTED_ORDER_EXPIRATION_INSTRUCTION = new MarketRuntimeException(ExceptionLanguageKeys.UNSUPPORTED_ORDER_EXPIRATION_INSTRUCTION, ExceptionType.IllegalArgumentException, "Order Expiration defined on the Order is not supported");	
	public static final MarketRuntimeException ORDER_CANNOT_BE_CREATED_NON_ACTIVE_MARKET = new MarketRuntimeException(ExceptionLanguageKeys.ORDER_CANNOT_BE_CREATED_NON_ACTIVE_MARKET, ExceptionType.IllegalStateException, "Order cannot be Created on a Non-Active Market");
	public static final MarketRuntimeException NON_EXISTENT_ORDER = new MarketRuntimeException(ExceptionLanguageKeys.NON_EXISTENT_ORDER, ExceptionType.IllegalArgumentException, "Non-Existent Order");
	public static final MarketRuntimeException TARGET_MARKET_NOT_SET_ON_ORDER = new MarketRuntimeException(ExceptionLanguageKeys.TARGET_MARKET_NOT_SET_ON_ORDER, ExceptionType.IllegalArgumentException, "Target Market is not set on Order");
	public static final MarketRuntimeException UNSUPPORTED_ORDER_PROPERTY = new MarketRuntimeException(ExceptionLanguageKeys.UNSUPPORTED_ORDER_PROPERTY, ExceptionType.IllegalArgumentException, "Unsupported Order Property");
	public static final MarketRuntimeException UNSUPPORTED_ORDER_PROPERTY_VALUE = new MarketRuntimeException(ExceptionLanguageKeys.UNSUPPORTED_ORDER_PROPERTY_VALUE, ExceptionType.IllegalArgumentException, "Unsupported Order Property value");
	public static final MarketRuntimeException DUPLICATE_ORDER_PROPERTY = new MarketRuntimeException(ExceptionLanguageKeys.DUPLICATE_ORDER_PROPERTY, ExceptionType.IllegalArgumentException, "Duplicate Property Value is set to Property List");
	public static final MarketRuntimeException UNSUPPORTED_ORDER_PROPERTY_CHANGE = new MarketRuntimeException(ExceptionLanguageKeys.UNSUPPORTED_ORDER_PROPERTY_CHANGE, ExceptionType.IllegalArgumentException, "Unsupported Order Property Change");
	public static final MarketRuntimeException LIMIT_ORDER_MUST_HAVE_A_VALID_LIMIT_QUOTE = new MarketRuntimeException(ExceptionLanguageKeys.LIMIT_ORDER_MUST_HAVE_A_VALID_LIMIT_QUOTE, ExceptionType.IllegalArgumentException, "Limit Order must have a valid Limit Quote");
	public static final MarketRuntimeException NULL_ORDER_CANNOT_BE_CREATED = new MarketRuntimeException(ExceptionLanguageKeys.NULL_ORDER_CANNOT_BE_CREATED, ExceptionType.IllegalArgumentException, "Null Order cannot be created");
	public static final MarketRuntimeException ORDER_ID_MUST_NOT_BE_DEFINED = new MarketRuntimeException(ExceptionLanguageKeys.ORDER_ID_MUST_NOT_BE_DEFINED, ExceptionType.IllegalArgumentException, "Order ID (Primary Key) must not be defined, it is defined by the system");
	public static final MarketRuntimeException ORDER_ALREADY_EXISTS = new MarketRuntimeException(ExceptionLanguageKeys.ORDER_ALREADY_EXISTS, ExceptionType.IllegalArgumentException, "Order cannot be created, already exists");
	public static final MarketRuntimeException MULTIPLE_ORDER_RETURNED_FOR_CODE = new MarketRuntimeException(ExceptionLanguageKeys.MULTIPLE_ORDER_RETURNED_FOR_CODE, ExceptionType.IllegalStateException, "Multiple Order returned for Primary Key");
	public static final MarketRuntimeException ORDER_CANNOT_BE_CREATED_ON_NON_EXISTENT_MARKET = new MarketRuntimeException(ExceptionLanguageKeys.ORDER_CANNOT_BE_CREATED_ON_NON_EXISTENT_MARKET, ExceptionType.IllegalArgumentException, "Order cannot be created on a non-existent Market");
	public static final MarketRuntimeException LIMIT_PRICE_MUST_BE_POSITIVE = new MarketRuntimeException(ExceptionLanguageKeys.LIMIT_PRICE_MUST_BE_POSITIVE, ExceptionType.IllegalArgumentException, "Limit Price must be Positive");
	public static final MarketRuntimeException LIMIT_YIELD_MUST_BE_LESS_THAN_100 = new MarketRuntimeException(ExceptionLanguageKeys.LIMIT_YIELD_MUST_BE_LESS_THAN_100, ExceptionType.IllegalArgumentException, "Limit Yield must be less than 100");
	public static final MarketRuntimeException STOP_PRICE_MUST_BE_POSITIVE = new MarketRuntimeException(ExceptionLanguageKeys.STOP_PRICE_MUST_BE_POSITIVE, ExceptionType.IllegalArgumentException, "Stop Price must be Positive");
	public static final MarketRuntimeException STOP_YIELD_MUST_BE_LESS_THAN_100 = new MarketRuntimeException(ExceptionLanguageKeys.STOP_YIELD_MUST_BE_LESS_THAN_100, ExceptionType.IllegalArgumentException, "Stop Yield must be less than 100");
	public static final MarketRuntimeException STOP_QUOTE_DIFFERENCE_MUST_BE_POSITIVE = new MarketRuntimeException(ExceptionLanguageKeys.STOP_QUOTE_DIFFERENCE_MUST_BE_POSITIVE, ExceptionType.IllegalArgumentException, "Stop Quote Difference must be Positive");	
	// Market Errors
	public static final MarketRuntimeException UNSUPPORTED_EXECUTION_SYSTEM_ORDER_MATCHING = new MarketRuntimeException(ExceptionLanguageKeys.UNSUPPORTED_EXECUTION_SYSTEM_ORDER_MATCHING, ExceptionType.IllegalStateException, "Execution System defined on the Market is not supported for Order Matching");
	public static final MarketRuntimeException UNSUPPORTED_EXECUTION_SYSTEM_PRICING_RULE = new MarketRuntimeException(ExceptionLanguageKeys.UNSUPPORTED_EXECUTION_SYSTEM_PRICING_RULE, ExceptionType.IllegalStateException, "Execution System defined on the Market is not supported for Order Pricing");
	public static final MarketRuntimeException NON_ACTIVE_MARKET_CANNOT_BE_OPENED = new MarketRuntimeException(ExceptionLanguageKeys.NON_ACTIVE_MARKET_CANNOT_BE_OPENED, ExceptionType.IllegalStateException, "Non-Active Market cannot be Opened");
	public static final MarketRuntimeException NON_ACTIVE_MARKET_CANNOT_BE_CALLED = new MarketRuntimeException(ExceptionLanguageKeys.NON_ACTIVE_MARKET_CANNOT_BE_CALLED, ExceptionType.IllegalStateException, "Non-Active Market cannot be Called");
	public static final MarketRuntimeException NON_ACTIVE_MARKET_CANNOT_BE_CLOSED = new MarketRuntimeException(ExceptionLanguageKeys.NON_ACTIVE_MARKET_CANNOT_BE_CLOSED, ExceptionType.IllegalStateException, "Non-Active Market cannot be Closed");
	public static final MarketRuntimeException NON_ACTIVE_MARKET_CANNOT_BE_HALTED = new MarketRuntimeException(ExceptionLanguageKeys.NON_ACTIVE_MARKET_CANNOT_BE_HALTED, ExceptionType.IllegalStateException, "Non-Active Market cannot be Halted");
	public static final MarketRuntimeException NON_OPEN_MARKET_CANNOT_BE_CLOSED = new MarketRuntimeException(ExceptionLanguageKeys.NON_OPEN_MARKET_CANNOT_BE_CLOSED, ExceptionType.IllegalStateException, "Non-Open Market cannot be Closed");
	public static final MarketRuntimeException NON_OPEN_MARKET_CANNOT_BE_HALTED = new MarketRuntimeException(ExceptionLanguageKeys.NON_OPEN_MARKET_CANNOT_BE_HALTED, ExceptionType.IllegalStateException, "Non-Open Market cannot be Halted");
	public static final MarketRuntimeException NON_CLOSED_MARKET_CANNOT_BE_OPENED = new MarketRuntimeException(ExceptionLanguageKeys.NON_CLOSED_MARKET_CANNOT_BE_OPENED, ExceptionType.IllegalStateException, "Non-Closed Market cannot be Opened");
	public static final MarketRuntimeException NON_HALTED_MARKET_CANNOT_BE_OPENED = new MarketRuntimeException(ExceptionLanguageKeys.NON_HALTED_MARKET_CANNOT_BE_OPENED, ExceptionType.IllegalStateException, "Non-Halted Market cannot be Opened");
	public static final MarketRuntimeException NON_CALL_MARKET_CANNOT_BE_CALLED = new MarketRuntimeException(ExceptionLanguageKeys.NON_CALL_MARKET_CANNOT_BE_CALLED, ExceptionType.IllegalStateException, "Non-Call Market cannot be Called");
	public static final MarketRuntimeException OPEN_MARKET_CAN_ONLY_BE_CALLED = new MarketRuntimeException(ExceptionLanguageKeys.OPEN_MARKET_CAN_ONLY_BE_CALLED, ExceptionType.IllegalStateException, "Open Market can only be Called");

	public static final MarketRuntimeException NON_EXISTENT_MARKET = new MarketRuntimeException(ExceptionLanguageKeys.NON_EXISTENT_MARKET, ExceptionType.IllegalArgumentException, "Non-Existent Market");

	// Message Handling Errors
	public static final MarketRuntimeException NULL_MESSAGE = new MarketRuntimeException(ExceptionLanguageKeys.NULL_MESSAGE, ExceptionType.IllegalArgumentException, "Null Message");
	public static final MarketRuntimeException UNSUPPORTED_MESSAGE = new MarketRuntimeException(ExceptionLanguageKeys.UNSUPPORTED_MESSAGE, ExceptionType.IllegalArgumentException, "Unsupported Message Type or Message Version");
	public static final MarketRuntimeException UNSUPPORTED_MARKET_OBJECT_TYPE = new MarketRuntimeException(ExceptionLanguageKeys.UNSUPPORTED_MARKET_OBJECT_TYPE, ExceptionType.IllegalArgumentException, "Unsupported Market Object Type");

	// Listener Errors
	public static final MarketRuntimeException NULL_LISTENER_CANNOT_BE_CREATED = new MarketRuntimeException(ExceptionLanguageKeys.NULL_LISTENER_CANNOT_BE_CREATED, ExceptionType.IllegalArgumentException, "Null Listener cannot be created");	
	public static final MarketRuntimeException LISTENER_CANNOT_BE_INSTANTIATED = new MarketRuntimeException(ExceptionLanguageKeys.LISTENER_CANNOT_BE_INSTANTIATED, ExceptionType.IllegalArgumentException, "Listener cannot be instantiated");
	public static final MarketRuntimeException LISTENER_CANNOT_BE_CREATED_WITH_NULL_OBSERVED_OBJECT = new MarketRuntimeException(ExceptionLanguageKeys.LISTENER_CANNOT_BE_CREATED_WITH_NULL_OBSERVED_OBJECT, ExceptionType.IllegalArgumentException, "Listener cannot be created with a Null Observed Object");
	public static final MarketRuntimeException LISTENER_CANNOT_BE_CREATED_WITH_NULL_OBSERVED_CLASS = new MarketRuntimeException(ExceptionLanguageKeys.LISTENER_CANNOT_BE_CREATED_WITH_NULL_OBSERVED_CLASS, ExceptionType.IllegalArgumentException, "Listener cannot be created with a Null Observed Class");
	public static final MarketRuntimeException LISTENER_CANNOT_BE_DELETED_WITH_NULL_OBSERVED_OBJECT = new MarketRuntimeException(ExceptionLanguageKeys.LISTENER_CANNOT_BE_DELETED_WITH_NULL_OBSERVED_OBJECT, ExceptionType.IllegalArgumentException, "Listener cannot be deleted with a Null Observed Object");
	public static final MarketRuntimeException LISTENER_CANNOT_BE_QUERIED_WITH_NULL_OBSERVED_OBJECT = new MarketRuntimeException(ExceptionLanguageKeys.LISTENER_CANNOT_BE_QUERIED_WITH_NULL_OBSERVED_OBJECT, ExceptionType.IllegalArgumentException, "Listener cannot be queried with a Null Observed Object");
	public static final MarketRuntimeException LISTENER_ALREADY_EXISTS = new MarketRuntimeException(ExceptionLanguageKeys.ASSET_CLASS_ALREADY_EXISTS, ExceptionType.IllegalArgumentException, "Listener cannot be created, already exists");
	public static final MarketRuntimeException MULTIPLE_LISTENERS_RETURNED_FOR_KEY = new MarketRuntimeException(ExceptionLanguageKeys.MULTIPLE_LISTENERS_RETURNED_FOR_KEY, ExceptionType.IllegalStateException, "Multiple Listeners returned for Primary Key");
	public static final MarketRuntimeException NON_EXISTENT_LISTENER = new MarketRuntimeException(ExceptionLanguageKeys.NON_EXISTENT_LISTENER, ExceptionType.IllegalArgumentException, "Listener cannot be found");
	
	// Connection Errors
	public static final MarketRuntimeException ERROR_CONNECTING_MARKET_SYSTEM = new MarketRuntimeException(ExceptionLanguageKeys.ERROR_CONNECTING_MARKET_SYSTEM, ExceptionType.IllegalStateException, "No connection could be made to Market System");
	
	// System Errors
	public static final MarketRuntimeException INTERNAL_SYSTEM_ERROR = new MarketRuntimeException(ExceptionLanguageKeys.INTERNAL_SYSTEM_ERROR, ExceptionType.IllegalStateException, "Internal System Error");
	
	// TODO: Should we move below to a different project ???

	// Asset Class Management Errors
	public static final MarketRuntimeException ASSET_CLASS_CANNOT_BE_OVERWRITTEN_WITH_AN_OLDER_VERSION = new MarketRuntimeException(ExceptionLanguageKeys.ASSET_CLASS_CANNOT_BE_OVERWRITTEN_WITH_AN_OLDER_VERSION, ExceptionType.IllegalArgumentException, "Asset Class cannot be Overwritten with an Older Version of the same Asset Class");
	public static final MarketRuntimeException ASSET_CLASS_WITHOUT_NAME = new MarketRuntimeException(ExceptionLanguageKeys.ASSET_CLASS_WITHOUT_VALID_NAME, ExceptionType.IllegalArgumentException, "Asset Class must have a valid name");
	public static final MarketRuntimeException ASSET_CLASS_WITHOUT_DESCRIPTION = new MarketRuntimeException(ExceptionLanguageKeys.ASSET_CLASS_WITHOUT_DESCRIPTION, ExceptionType.IllegalArgumentException, "Asset Class must have description");
	public static final MarketRuntimeException ASSET_CLASS_NAME_CANNOT_BE_CHANGED = new MarketRuntimeException(ExceptionLanguageKeys.ASSET_CLASS_NAME_CANNOT_BE_CHANGED, ExceptionType.IllegalArgumentException, "Asset Class name cannot be changed a new needs to be created");
	public static final MarketRuntimeException ASSET_CLASS_CANNOT_BE_DELETED_IF_IT_IS_ASSIGNED_TO_INSTRUMENTS = new MarketRuntimeException(ExceptionLanguageKeys.ASSET_CLASS_CANNOT_BE_DELETED_IF_IT_IS_ASSIGNED_TO_INSTRUMENTS, ExceptionType.IllegalStateException, "Asset Class cannot be deleted, if it is assigned to Instruments");
	public static final MarketRuntimeException NULL_ASSET_CLASS_CANNOT_BE_CREATED = new MarketRuntimeException(ExceptionLanguageKeys.NULL_ASSET_CLASS_CANNOT_BE_CREATED, ExceptionType.IllegalArgumentException, "Null Asset Class cannot be created");	
	public static final MarketRuntimeException ASSET_CLASS_CANNOT_BE_CREATED_WITH_NULL_NAME = new MarketRuntimeException(ExceptionLanguageKeys.ASSET_CLASS_CANNOT_BE_CREATED_WITH_NULL_NAME, ExceptionType.IllegalArgumentException, "Asset Class cannot be created with a Null Name");
	public static final MarketRuntimeException ASSET_CLASS_ALREADY_EXISTS = new MarketRuntimeException(ExceptionLanguageKeys.ASSET_CLASS_ALREADY_EXISTS, ExceptionType.IllegalArgumentException, "Asset Class cannot be created, already exists");
	public static final MarketRuntimeException MULTIPLE_ASSET_CLASSES_RETURNED_FOR_NAME = new MarketRuntimeException(ExceptionLanguageKeys.MULTIPLE_ASSET_CLASSES_RETURNED_FOR_NAME, ExceptionType.IllegalStateException, "Multiple Asset Class returned for a Name (Primary Key)");
	public static final MarketRuntimeException NON_EXISTENT_ASSET_CLASS = new MarketRuntimeException(ExceptionLanguageKeys.NON_EXISTENT_ASSET_CLASS, ExceptionType.IllegalArgumentException, "Non-Existent Asset Class");
	public static final MarketRuntimeException TOO_MANY_ASSET_CLASSES_FOR_THIS_PARENT = new MarketRuntimeException(ExceptionLanguageKeys.TOO_MANY_ASSET_CLASSES_FOR_THIS_PARENT, ExceptionType.IllegalArgumentException, "Too Many Asset Classes for this Parent");
	public static final MarketRuntimeException TOO_DEEP_ASSET_CLASS_TREE = new MarketRuntimeException(ExceptionLanguageKeys.TOO_DEEP_ASSET_CLASS_TREE, ExceptionType.IllegalArgumentException, "Too Deep Asset Class Tree");
	public static final MarketRuntimeException CIRCULAR_ASSET_CLASS_TREE = new MarketRuntimeException(ExceptionLanguageKeys.CIRCULAR_ASSET_CLASS_TREE, ExceptionType.IllegalArgumentException, "Circular Asset Class Tree");
	public static final MarketRuntimeException ASSET_CLASS_PARENT_NAME_INVALID = new MarketRuntimeException(ExceptionLanguageKeys.ASSET_CLASS_PARENT_NAME_INVALID, ExceptionType.IllegalArgumentException, "Asset Class Parent Name Invalid");
		
	// Product Management Errors 
	public static final MarketRuntimeException PRODUCT_CANNOT_BE_OVERWRITTEN_WITH_AN_OLDER_VERSION = new MarketRuntimeException(ExceptionLanguageKeys.PRODUCT_CANNOT_BE_OVERWRITTEN_WITH_AN_OLDER_VERSION, ExceptionType.IllegalArgumentException, "Product cannot be Overwritten with an Older Version of the same Product");
	public static final MarketRuntimeException PRODUCT_MUST_HAVE_PRODUCT_VALID_CODE = new MarketRuntimeException(ExceptionLanguageKeys.PRODUCT_MUST_HAVE_PRODUCT_VALID_CODE, ExceptionType.IllegalArgumentException, "Product must have a valid Product Code (Primary Key)");
	public static final MarketRuntimeException PRODUCT_MUST_HAVE_NAME = new MarketRuntimeException(ExceptionLanguageKeys.PRODUCT_MUST_HAVE_NAME, ExceptionType.IllegalArgumentException, "Product must have a Name");
	public static final MarketRuntimeException PRODUCT_MUST_HAVE_DESCRIPTION = new MarketRuntimeException(ExceptionLanguageKeys.PRODUCT_MUST_HAVE_DESCRIPTION, ExceptionType.IllegalArgumentException, "Product must have a Description");
	public static final MarketRuntimeException PRODUCT_MUST_HAVE_PRODUCT_TYPE = new MarketRuntimeException(ExceptionLanguageKeys.PRODUCT_MUST_HAVE_PRODUCT_TYPE, ExceptionType.IllegalArgumentException, "Product must have a Product Type");
	public static final MarketRuntimeException PRODUCT_MUST_HAVE_DEFINITION_DOCUMENT = new MarketRuntimeException(ExceptionLanguageKeys.PRODUCT_MUST_HAVE_DEFINITION_DOCUMENT, ExceptionType.IllegalArgumentException, "Product must have a Definition Document");
	public static final MarketRuntimeException NEW_PRODUCT_MUST_NOT_HAVE_PRODUCT_CODE_ROLLED_FROM = new MarketRuntimeException(ExceptionLanguageKeys.NEW_PRODUCT_MUST_NOT_HAVE_PRODUCT_CODE_ROLLED_FROM, ExceptionType.IllegalArgumentException, "New Product must not have Product Code Rolled From");
	public static final MarketRuntimeException NEW_PRODUCT_MUST_NOT_HAVE_ACTIVATION_DATE = new MarketRuntimeException(ExceptionLanguageKeys.NEW_PRODUCT_MUST_NOT_HAVE_ACTIVATION_DATE, ExceptionType.IllegalArgumentException, "New Product must not have Activation Date");
	public static final MarketRuntimeException NEW_PRODUCT_MUST_NOT_HAVE_CREATION_AUDIT = new MarketRuntimeException(ExceptionLanguageKeys.NEW_PRODUCT_MUST_NOT_HAVE_CREATION_AUDIT, ExceptionType.IllegalArgumentException, "New Product must not have Creation Audit");
	public static final MarketRuntimeException NEW_PRODUCT_MUST_NOT_HAVE_CHANGE_AUDIT = new MarketRuntimeException(ExceptionLanguageKeys.NEW_PRODUCT_MUST_NOT_HAVE_CHANGE_AUDIT, ExceptionType.IllegalArgumentException, "New Product must not have Change Audit");
	public static final MarketRuntimeException NEW_PRODUCT_MUST_NOT_HAVE_ROLLOVER_AUDIT = new MarketRuntimeException(ExceptionLanguageKeys.NEW_PRODUCT_MUST_NOT_HAVE_ROLLOVER_AUDIT, ExceptionType.IllegalArgumentException, "New Product must not have Rollover Audit");
	public static final MarketRuntimeException NEW_PRODUCT_MUST_NOT_HAVE_APPROVAL_AUDIT = new MarketRuntimeException(ExceptionLanguageKeys.NEW_PRODUCT_MUST_NOT_HAVE_APPROVAL_AUDIT, ExceptionType.IllegalArgumentException, "New Product must not have Approval Audit");
	public static final MarketRuntimeException NEW_PRODUCT_MUST_NOT_HAVE_SUSPENSION_AUDIT = new MarketRuntimeException(ExceptionLanguageKeys.NEW_PRODUCT_MUST_NOT_HAVE_SUSPENSION_AUDIT, ExceptionType.IllegalArgumentException, "New Product must not have Suspension Audit");
	public static final MarketRuntimeException NEW_PRODUCT_MUST_NOT_HAVE_ACTIVATION_STATUS = new MarketRuntimeException(ExceptionLanguageKeys.NEW_PRODUCT_MUST_NOT_HAVE_ACTIVATION_STATUS, ExceptionType.IllegalArgumentException, "New Product must not have Activation Status");
	public static final MarketRuntimeException NEW_PRODUCT_MUST_NOT_HAVE_DEFINITION_DOCUMENT = new MarketRuntimeException(ExceptionLanguageKeys.NEW_PRODUCT_MUST_NOT_HAVE_DEFINITION_DOCUMENT, ExceptionType.IllegalArgumentException, "New Product must not have Definition Document");
	public static final MarketRuntimeException PRODUCT_TYPE_CANNOT_BE_CHANGED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.PRODUCT_TYPE_CANNOT_BE_CHANGED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Product Type cannot be changed while Rollover");
	public static final MarketRuntimeException PRODUCT_DEFINITION_DOCUMENT_CANNOT_BE_CHANGED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.PRODUCT_DEFINITION_DOCUMENT_CANNOT_BE_CHANGED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Product Defiinition Document cannot be changed while Rollover");
	public static final MarketRuntimeException PRODUCT_CATEGORY_CANNOT_BE_CHANGED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.PRODUCT_CATEGORY_CANNOT_BE_CHANGED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Product Category cannot be changed while Rollover");
	public static final MarketRuntimeException PRODUCT_SUB_CATEGORY_CANNOT_BE_CHANGED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.PRODUCT_SUB_CATEGORY_CANNOT_BE_CHANGED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Product Sub-Category cannot be changed while Rollover");
	public static final MarketRuntimeException NULL_PRODUCT_CANNOT_BE_CREATED = new MarketRuntimeException(ExceptionLanguageKeys.NULL_PRODUCT_CANNOT_BE_CREATED, ExceptionType.IllegalArgumentException, "Null Product cannot be created");
	public static final MarketRuntimeException PRODUCT_CANNOT_BE_CREATED_WITH_NULL_CODE = new MarketRuntimeException(ExceptionLanguageKeys.PRODUCT_CANNOT_BE_CREATED_WITH_NULL_CODE, ExceptionType.IllegalArgumentException, "Product cannot be created with a Null Code (Primary Key)");
	public static final MarketRuntimeException PRODUCT_ALREADY_EXISTS = new MarketRuntimeException(ExceptionLanguageKeys.PRODUCT_ALREADY_EXISTS, ExceptionType.IllegalArgumentException, "Product cannot be created, already exists");
	public static final MarketRuntimeException MULTIPLE_PRODUCTS_RETURNED_FOR_CODE = new MarketRuntimeException(ExceptionLanguageKeys.MULTIPLE_PRODUCTS_RETURNED_FOR_CODE, ExceptionType.IllegalStateException, "Multiple Products returned for a Code (Primary Key)");
	public static final MarketRuntimeException NON_EXISTENT_PRODUCT = new MarketRuntimeException(ExceptionLanguageKeys.NON_EXISTENT_PRODUCT, ExceptionType.IllegalArgumentException, "Non-Existent Product");
	public static final MarketRuntimeException PRODUCT_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_CHANGED = new MarketRuntimeException(ExceptionLanguageKeys.PRODUCT_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_CHANGED, ExceptionType.IllegalStateException, "Product only in Created or Suspended State can be Changed");
	public static final MarketRuntimeException PRODUCT_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_DELETED = new MarketRuntimeException(ExceptionLanguageKeys.PRODUCT_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_DELETED, ExceptionType.IllegalStateException, "Product only in Created or Suspended State can be Deleted");
	public static final MarketRuntimeException PRODUCT_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_APPROVED = new MarketRuntimeException(ExceptionLanguageKeys.PRODUCT_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_APPROVED, ExceptionType.IllegalStateException, "Product only in Created or Suspended State can be Approved");
	public static final MarketRuntimeException PRODUCT_NOT_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_SUSPENDED = new MarketRuntimeException(ExceptionLanguageKeys.PRODUCT_NOT_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_SUSPENDED, ExceptionType.IllegalStateException, "Product NOT in Created or Suspended State can be Suspended");
	public static final MarketRuntimeException PRODUCT_THAT_HAS_NO_APPROVED_DEPENDENT_INSTRUMENTS_CAN_BE_FORCED_TO_BE_CHANGED = new MarketRuntimeException(ExceptionLanguageKeys.PRODUCT_THAT_HAS_NO_APPROVED_DEPENDENT_INSTRUMENTS_CAN_BE_FORCED_TO_BE_CHANGED, ExceptionType.IllegalArgumentException, "Only Product that has no approved dependent Instrument can be forced to be changed");
	public static final MarketRuntimeException PRODUCT_THAT_HAS_NO_DEPENDENT_INSTRUMENTS_CAN_BE_DELETED = new MarketRuntimeException(ExceptionLanguageKeys.PRODUCT_THAT_HAS_NO_DEPENDENT_INSTRUMENTS_CAN_BE_DELETED, ExceptionType.IllegalArgumentException, "Only Product that has no dependent Instrument can be deleted");
	public static final MarketRuntimeException PRODUCT_CAN_ONLY_BE_SUSPENDED_IF_DEPENDENT_OBJECTS_ARE_SUSPENDED = new MarketRuntimeException(ExceptionLanguageKeys.PRODUCT_CAN_ONLY_BE_SUSPENDED_IF_DEPENDENT_OBJECTS_ARE_SUSPENDED, ExceptionType.IllegalStateException, "Product can only be suspended, if dependent objects are suspended");
	public static final MarketRuntimeException CATEGORY_MUST_BE_VALID = new MarketRuntimeException(ExceptionLanguageKeys.CATEGORY_MUST_BE_VALID, ExceptionType.IllegalArgumentException, "Category must be Valid");
	public static final MarketRuntimeException SUB_CATEGORY_MUST_BE_VALID = new MarketRuntimeException(ExceptionLanguageKeys.SUB_CATEGORY_MUST_BE_VALID, ExceptionType.IllegalArgumentException, "Sub-category must be Valid");

	// Instrument Management Error 	
	public static final MarketRuntimeException INSTRUMENT_CANNOT_BE_OVERWRITTEN_WITH_AN_OLDER_VERSION = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_CANNOT_BE_OVERWRITTEN_WITH_AN_OLDER_VERSION, ExceptionType.IllegalArgumentException, "Instrument cannot be Overwritten with an Older Version of the same Instrument");
	public static final MarketRuntimeException NULL_INSTRUMENT_CANNOT_BE_CREATED = new MarketRuntimeException(ExceptionLanguageKeys.NULL_INSTRUMENT_CANNOT_BE_CREATED, ExceptionType.IllegalArgumentException, "Null Instrument cannot be created");
	public static final MarketRuntimeException INSTRUMENT_CANNOT_BE_CREATED_WITH_NULL_CODE = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_CANNOT_BE_CREATED_WITH_NULL_CODE, ExceptionType.IllegalArgumentException, "Instrument cannot be created with a Null Code (Primary Key)");
	public static final MarketRuntimeException INSTRUMENT_ALREADY_EXISTS = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_ALREADY_EXISTS, ExceptionType.IllegalArgumentException, "Instrument cannot be created, already exists");
	public static final MarketRuntimeException MULTIPLE_INSTRUMENT_RETURNED_FOR_CODE = new MarketRuntimeException(ExceptionLanguageKeys.MULTIPLE_INSTRUMENTS_RETURNED_FOR_CODE, ExceptionType.IllegalStateException, "Multiple Instrument returned for a Code (Primary Key)");
	public static final MarketRuntimeException INSTRUMENT_MUST_HAVE_VALID_CODE = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_MUST_HAVE_VALID_CODE, ExceptionType.IllegalArgumentException, "Instrument must have a valid Instrument Code (Primary Key)");
	public static final MarketRuntimeException INSTRUMENT_MUST_HAVE_NAME = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_MUST_HAVE_NAME, ExceptionType.IllegalArgumentException, "Instrument must have a Name");
	public static final MarketRuntimeException INSTRUMENT_MUST_HAVE_DESCRIPTION = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_MUST_HAVE_DESCRIPTION, ExceptionType.IllegalArgumentException, "Instrument must have a Description");
	public static final MarketRuntimeException INSTRUMENT_MUST_HAVE_INSTRUMENT_TYPE = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_MUST_HAVE_INSTRUMENT_TYPE, ExceptionType.IllegalArgumentException, "Instrument must have a Instrument Type");
	public static final MarketRuntimeException INSTRUMENT_MUST_HAVE_UNDERLYING_CODE = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_MUST_HAVE_UNDERLYING_CODE, ExceptionType.IllegalArgumentException, "Instrument must have a Underlying Code");
	public static final MarketRuntimeException INSTRUMENT_MUST_HAVE_UNDERLYING_TYPE = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_MUST_HAVE_UNDERLYING_TYPE, ExceptionType.IllegalArgumentException, "Instrument must have a Underlying Type");
	public static final MarketRuntimeException INSTRUMENT_MUST_HAVE_DENOMINATION_CURRENCY = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_MUST_HAVE_DENOMINATION_CURRENCY, ExceptionType.IllegalArgumentException, "Instrument must have a Denomination Currency");
	public static final MarketRuntimeException INSTRUMENT_MUST_HAVE_CONTRACT_SIZE = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_MUST_HAVE_CONTRACT_SIZE, ExceptionType.IllegalArgumentException, "Instrument must have Contract Size");
	public static final MarketRuntimeException INSTRUMENT_MUST_HAVE_CONTRACT_SIZE_UNIT = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_MUST_HAVE_CONTRACT_SIZE_UNIT, ExceptionType.IllegalArgumentException, "Instrument must have Contract Size Unit");
	public static final MarketRuntimeException INSTRUMENT_MUST_HAVE_MASTER_AGREEMENT_DOCUMENT = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_MUST_HAVE_MASTER_AGREEMENT_DOCUMENT, ExceptionType.IllegalArgumentException, "Instrument must have a Master Agreement Document");
	public static final MarketRuntimeException INSTRUMENT_MUST_HAVE_QUOTE_TYPE = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_MUST_HAVE_QUOTE_TYPE, ExceptionType.IllegalArgumentException, "Instrument must have a Quote Type");
	public static final MarketRuntimeException INSTRUMENT_MUST_HAVE_SETTLEMENT_PRICE_TYPE = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_MUST_HAVE_SETTLEMENT_PRICE_TYPE, ExceptionType.IllegalArgumentException, "Instrument must have a Settlment Price Type");
	public static final MarketRuntimeException ONLY_CLEAN_SETTLEMENT_PRICE_TYPE_IS_SUPPORTED_ON_INSTRUMENTS = new MarketRuntimeException(ExceptionLanguageKeys.ONLY_CLEAN_SETTLEMENT_PRICE_TYPE_IS_SUPPORTED_ON_INSTRUMENTS, ExceptionType.IllegalArgumentException, "Only Clean Settlement Price Type is supported on Instruments");
	public static final MarketRuntimeException INSTRUMENT_MUST_HAVE_SETTLEMENT_TYPE = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_MUST_HAVE_SETTLEMENT_TYPE, ExceptionType.IllegalArgumentException, "Instrument must have a Settlement Type");	
	public static final MarketRuntimeException INSTRUMENT_MUST_HAVE_DELIVERY_PERIOD = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_MUST_HAVE_DELIVERY_PERIOD, ExceptionType.IllegalArgumentException, "Instrument must have a Delivery Period");
	public static final MarketRuntimeException INSTRUMENT_MUST_HAVE_RECORD_PURSCHASE_AS_TYPE = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_MUST_HAVE_RECORD_PURSCHASE_AS_TYPE, ExceptionType.IllegalArgumentException, "Instrument must have a Record Purchase As - Type");
	public static final MarketRuntimeException ONLY_LONG_RECORD_PURSCHASE_AS_TYPE_SUPPORTED_ON_INSTRUMENTS = new MarketRuntimeException(ExceptionLanguageKeys.ONLY_LONG_RECORD_PURSCHASE_AS_TYPE_SUPPORTED_ON_INSTRUMENTS, ExceptionType.IllegalArgumentException, "Only Long is supported for Record Purchase As on Instruments");
	public static final MarketRuntimeException INSTRUMENT_MUST_HAVE_DELIVERY_LOCATION_FOR_PHYSICAL_DELIVERY = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_MUST_HAVE_DELIVERY_LOCATION_FOR_PHYSICAL_DELIVERY, ExceptionType.IllegalArgumentException, "Instrument must have a Delivery Location for Physical Delivery");
	public static final MarketRuntimeException NEW_INSTRUMENT_MUST_NOT_HAVE_INSTRUMENT_CODE_ROLLED_FROM = new MarketRuntimeException(ExceptionLanguageKeys.NEW_INSTRUMENT_MUST_NOT_HAVE_INSTRUMENT_CODE_ROLLED_FROM, ExceptionType.IllegalArgumentException, "New Instrument must not have Instrument Code Rolled From");
	public static final MarketRuntimeException NEW_INSTRUMENT_MUST_NOT_HAVE_ACTIVATION_DATE = new MarketRuntimeException(ExceptionLanguageKeys.NEW_INSTRUMENT_MUST_NOT_HAVE_ACTIVATION_DATE, ExceptionType.IllegalArgumentException, "New Instrument must not have Activation Date");
	public static final MarketRuntimeException NEW_INSTRUMENT_MUST_NOT_HAVE_CREATION_AUDIT = new MarketRuntimeException(ExceptionLanguageKeys.NEW_INSTRUMENT_MUST_NOT_HAVE_CREATION_AUDIT, ExceptionType.IllegalArgumentException, "New Instrument must not have Creation Audit");
	public static final MarketRuntimeException NEW_INSTRUMENT_MUST_NOT_HAVE_CHANGE_AUDIT = new MarketRuntimeException(ExceptionLanguageKeys.NEW_INSTRUMENT_MUST_NOT_HAVE_CHANGE_AUDIT, ExceptionType.IllegalArgumentException, "New Instrument must not have Change Audit");
	public static final MarketRuntimeException NEW_INSTRUMENT_MUST_NOT_HAVE_ROLLOVER_AUDIT = new MarketRuntimeException(ExceptionLanguageKeys.NEW_INSTRUMENT_MUST_NOT_HAVE_ROLLOVER_AUDIT, ExceptionType.IllegalArgumentException, "New Instrument must not have Rollover Audit");
	public static final MarketRuntimeException NEW_INSTRUMENT_MUST_NOT_HAVE_APPROVAL_AUDIT = new MarketRuntimeException(ExceptionLanguageKeys.NEW_INSTRUMENT_MUST_NOT_HAVE_APPROVAL_AUDIT, ExceptionType.IllegalArgumentException, "New Instrument must not have Approval Audit");
	public static final MarketRuntimeException NEW_INSTRUMENT_MUST_NOT_HAVE_SUSPENSION_AUDIT = new MarketRuntimeException(ExceptionLanguageKeys.NEW_INSTRUMENT_MUST_NOT_HAVE_SUSPENSION_AUDIT, ExceptionType.IllegalArgumentException, "New Instrument must not have Suspension Audit");
	public static final MarketRuntimeException NEW_INSTRUMENT_MUST_NOT_HAVE_ACTIVATION_STATUS = new MarketRuntimeException(ExceptionLanguageKeys.NEW_INSTRUMENT_MUST_NOT_HAVE_ACTIVATION_STATUS, ExceptionType.IllegalArgumentException, "New Instrument must not have Activation Status");
	public static final MarketRuntimeException NEW_INSTRUMENT_MUST_NOT_HAVE_MASTER_AGREEMENT_DOCUMENT = new MarketRuntimeException(ExceptionLanguageKeys.NEW_INSTRUMENT_MUST_NOT_HAVE_MASTER_AGREEMENT_DOCUMENT, ExceptionType.IllegalArgumentException, "New Instrument must not have Master Agreement Document");
	public static final MarketRuntimeException NEW_INSTRUMENT_MUST_NOT_HAVE_ASSET_CLASS_NAME = new MarketRuntimeException(ExceptionLanguageKeys.NEW_INSTRUMENT_MUST_NOT_HAVE_ASSET_CLASS_NAME, ExceptionType.IllegalArgumentException, "New Instrument must not have Asset Class Name");
	public static final MarketRuntimeException NON_EXISTENT_INSTRUMENT = new MarketRuntimeException(ExceptionLanguageKeys.NON_EXISTENT_INSTRUMENT, ExceptionType.IllegalArgumentException, "Non-Existent Instrument");
	public static final MarketRuntimeException INSTRUMENT_TYPE_CANNOT_BE_CHANGED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_TYPE_CANNOT_BE_CHANGED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Instrument Type cannot be changed while Rollover");
	public static final MarketRuntimeException INSTRUMENT_ASSET_CLASS_CANNOT_BE_CHANGED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_ASSET_CLASS_CANNOT_BE_CHANGED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Instrument Asset Class cannot be changed while Rollover");
	public static final MarketRuntimeException INSTRUMENT_SUB_TYPE_CANNOT_BE_CHANGED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_SUB_TYPE_CANNOT_BE_CHANGED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Instrument Sub Type cannot be changed while Rollover");	
	public static final MarketRuntimeException INSTRUMENT_UNDERLYING_TYPE_CANNOT_BE_CHANGED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_UNDERLYING_TYPE_CANNOT_BE_CHANGED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Instrument Underlying Type cannot be changed while Rollover");
	public static final MarketRuntimeException INSTRUMENT_MASTER_AGREEMENT_CANNOT_BE_CHANGED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_MASTER_AGREEMENT_CANNOT_BE_CHANGED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Instrument Master Agreement cannot be changed while Rollover");
	public static final MarketRuntimeException INSTRUMENT_QUOTE_TYPE_CANNOT_BE_CHANGED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_QUOTE_TYPE_CANNOT_BE_CHANGED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Instrument Quote Type cannot be changed while Rollover");	
	public static final MarketRuntimeException INSTRUMENT_DENOMINATION_CURRENCY_CANNOT_BE_CHANGED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_DENOMINATION_CURRENCY_CANNOT_BE_CHANGED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Instrument Denomination Currency cannot be changed while Rollover");
	public static final MarketRuntimeException INSTRUMENT_CONTRACT_SIZE_CANNOT_BE_CHANGED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_CONTRACT_SIZE_CANNOT_BE_CHANGED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Instrument Contract Size cannot be Changed while Rolled Over");
	public static final MarketRuntimeException INSTRUMENT_CONTRACT_SIZE_UNIT_CANNOT_BE_CHANGED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_CONTRACT_SIZE_UNIT_CANNOT_BE_CHANGED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Instrument Contract Size Unit cannot be Changed while Rolled Over");
	public static final MarketRuntimeException INSTRUMENT_SETTLEMENT_PRICE_TYPE_CANNOT_BE_CHANGED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_SETTLEMENT_PRICE_TYPE_CANNOT_BE_CHANGED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Instrument Settlement Price Type cannot be changed while Rollover");	
	public static final MarketRuntimeException INSTRUMENT_SETTLEMENT_TYPE_CANNOT_BE_CHANGED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_SETTLEMENT_TYPE_CANNOT_BE_CHANGED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Instrument Settlement Type cannot be changed while Rollover");		
	public static final MarketRuntimeException INSTRUMENT_DELIVERY_PERIOD_CANNOT_BE_CHANGED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_DELIVERY_PERIOD_CANNOT_BE_CHANGED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Instrument Delivery Period cannot be changed while Rollover");
	public static final MarketRuntimeException INSTRUMENT_DELIVERY_LOCATION_CANNOT_BE_CHANGED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_DELIVERY_LOCATION_CANNOT_BE_CHANGED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Instrument Delivery Location cannot be changed while Rollover");
	public static final MarketRuntimeException INSTRUMENT_RECORD_PURCHASE_AS_TYPE_CANNOT_BE_CHANGED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_RECORD_PURCHASE_AS_TYPE_CANNOT_BE_CHANGED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Instrument Record Purchase As Type cannot be changed while Rollover");
	public static final MarketRuntimeException INSTRUMENT_THAT_HAS_NO_DEPENDENT_INSTRUMENTS_OR_MARKETS_CAN_BE_SUSPENDED = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_THAT_HAS_NO_DEPENDENT_INSTRUMENTS_OR_MARKETS_CAN_BE_SUSPENDED, ExceptionType.IllegalArgumentException, "Only Instrument that has no dependent Instrument or Market can be suspended, suspend the dependent Instrument or Market first");
	public static final MarketRuntimeException INSTRUMENT_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_CHANGED = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_CHANGED, ExceptionType.IllegalStateException, "Instrument only in Created or Suspended State can be Changed");
	public static final MarketRuntimeException INSTRUMENT_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_DELETED = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_DELETED, ExceptionType.IllegalStateException, "Instrument only in Created or Suspended State can be Deleted");
	public static final MarketRuntimeException INSTRUMENT_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_APPROVED = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_APPROVED, ExceptionType.IllegalStateException, "Instrument only in Created or Suspended State can be Approved");
	public static final MarketRuntimeException INSTRUMENT_NOT_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_SUSPENDED = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_NOT_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_SUSPENDED, ExceptionType.IllegalStateException, "Instrument NOT in Created or Suspended State can be Suspended");
	public static final MarketRuntimeException INSTRUMENT_THAT_HAS_NO_APPROVED_DEPENDENT_INSTRUMENTS_OR_MARKETS_CAN_BE_FORCED_TO_BE_CHANGED = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_THAT_HAS_NO_APPROVED_DEPENDENT_INSTRUMENTS_OR_MARKET_CAN_BE_FORCED_TO_BE_CHANGED, ExceptionType.IllegalArgumentException, "Only Instrument that has no approved dependent Instrument or Market can be forced to be changed");
	public static final MarketRuntimeException INSTRUMENT_THAT_HAS_NO_DEPENDENT_INSTRUMENTS_OR_MARKETS_CAN_BE_DELETED = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_THAT_HAS_NO_DEPENDENT_INSTRUMENTS_OR_MARKET_CAN_BE_DELETED, ExceptionType.IllegalArgumentException, "Only Instrument that has no dependent Instrument or Market can be deleted");
	public static final MarketRuntimeException NON_EXISTENT_UNDERLYING = new MarketRuntimeException(ExceptionLanguageKeys.NON_EXISTENT_UNDERLYING, ExceptionType.IllegalArgumentException, "Non-Existent Underlying");
	public static final MarketRuntimeException INSTRUMENT_CAN_ONLY_BE_APPROVED_IF_UNDERLYING_IS_APPROVED = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_CAN_ONLY_BE_APPROVED_IF_UNDERLYING_IS_APPROVED, ExceptionType.IllegalStateException, "Instrument can only be approved, if underlying object is approved");
	public static final MarketRuntimeException INSTRUMENT_CAN_ONLY_BE_SUSPENDED_IF_DEPENDENT_OBJECTS_ARE_SUSPENDED = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_CAN_ONLY_BE_SUSPENDED_IF_DEPENDENT_OBJECTS_ARE_SUSPENDED, ExceptionType.IllegalStateException, "Instrument can only be suspended, if dependent objects are suspended");
	public static final MarketRuntimeException INSTRUMENT_MUST_HAVE_ASSET_CLASS_NAME_FOR_APPROVAL = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_MUST_HAVE_ASSET_CLASS_NAME_FOR_APPROVAL, ExceptionType.IllegalArgumentException, "Instrument must have Asset Class Name for Approval");
	// public static final MarketRuntimeException SPOT_INSTRUMENT_MUST_HAVE_PRODUCT_UNDERLYING = new MarketRuntimeException(ExceptionLanguageKeys.SPOT_INSTRUMENT_MUST_HAVE_PRODUCT_UNDERLYING, ExceptionType.IllegalArgumentException, "Spot Instrument must have an Product Underlying");
	// public static final MarketRuntimeException DERIVATIVE_INSTRUMENT_MUST_HAVE_INSTRUMENT_UNDERLYING = new MarketRuntimeException(ExceptionLanguageKeys.DERIVATIVE_INSTRUMENT_MUST_HAVE_INSTRUMENT_UNDERLYING, ExceptionType.IllegalArgumentException, "Derivative Instrument must have an Instrument Underlying");
	public static final MarketRuntimeException INSTRUMENT_MUST_HAVE_CURRENCY_OR_UNIT = new MarketRuntimeException(ExceptionLanguageKeys.INSTRUMENT_MUST_HAVE_CURRENCY_OR_UNIT, ExceptionType.IllegalArgumentException, "Instrument must have Currency or Unit");
	public static final MarketRuntimeException TOO_DEEP_UNDERLYING_DEPENDENCY = new MarketRuntimeException(ExceptionLanguageKeys.TOO_DEEP_UNDERLYING_DEPENDENCY, ExceptionType.IllegalArgumentException, "Too deep dependency for Underlying");
	public static final MarketRuntimeException CIRCULAR_UNDERLYING_DEPENDENCY = new MarketRuntimeException(ExceptionLanguageKeys.CIRCULAR_UNDERLYING_DEPENDENCY, ExceptionType.IllegalArgumentException, "Circular dependency for Underlying");
	public static final MarketRuntimeException ISIN_MUST_BE_VALID = new MarketRuntimeException(ExceptionLanguageKeys.ISIN_MUST_BE_VALID, ExceptionType.IllegalArgumentException, "ISIN must be Valid");
	public static final MarketRuntimeException SUB_TYPE_MUST_BE_VALID = new MarketRuntimeException(ExceptionLanguageKeys.SUB_TYPE_MUST_BE_VALID, ExceptionType.IllegalArgumentException, "Sub-type must be Valid");

	// Corporate Information Errors
	public static final MarketRuntimeException CORPORATE_INFORMATION_MUST_HAVE_NAME = new MarketRuntimeException(ExceptionLanguageKeys.CORPORATE_INFORMATION_MUST_HAVE_NAME, ExceptionType.IllegalArgumentException, "Corporate Information must have Name");
	public static final MarketRuntimeException CORPORATE_INFORMATION_MUST_HAVE_ADDRESS = new MarketRuntimeException(ExceptionLanguageKeys.CORPORATE_INFORMATION_MUST_HAVE_ADDRESS, ExceptionType.IllegalArgumentException, "Corporate Information must have Address");
	public static final MarketRuntimeException CORPORATE_WEBSITE_MUST_BE_VALID = new MarketRuntimeException(ExceptionLanguageKeys.CORPORATE_WEBSITE_MUST_BE_VALID, ExceptionType.IllegalArgumentException, "Corporate Information must have Address");

	// Address Errors
	public static final MarketRuntimeException ADDRESS_MUST_HAVE_STREET = new MarketRuntimeException(ExceptionLanguageKeys.ADDRESS_MUST_HAVE_STREET, ExceptionType.IllegalArgumentException, "Address must have a Street Part");
	public static final MarketRuntimeException ADDRESS_MUST_HAVE_CITY = new MarketRuntimeException(ExceptionLanguageKeys.ADDRESS_MUST_HAVE_CITY, ExceptionType.IllegalArgumentException, "Address must have a City Part");
	public static final MarketRuntimeException ADDRESS_MUST_HAVE_COUNTRY = new MarketRuntimeException(ExceptionLanguageKeys.ADDRESS_MUST_HAVE_COUNTRY, ExceptionType.IllegalArgumentException, "Address must have a Country Part");
	public static final MarketRuntimeException ADDRESS_MUST_HAVE_POSTAL_CODE = new MarketRuntimeException(ExceptionLanguageKeys.ADDRESS_MUST_HAVE_POSTAL_CODE, ExceptionType.IllegalArgumentException, "Address must have a Postal Code Part");
	
	// Time Period Errors
	public static final MarketRuntimeException TIME_PERIOD_MUST_HAVE_START_TIME = new MarketRuntimeException(ExceptionLanguageKeys.TIME_PERIOD_MUST_HAVE_START_TIME, ExceptionType.IllegalArgumentException, "Time Period must have Start Time");
	public static final MarketRuntimeException TIME_PERIOD_MUST_HAVE_END_TIME = new MarketRuntimeException(ExceptionLanguageKeys.TIME_PERIOD_MUST_HAVE_END_TIME, ExceptionType.IllegalArgumentException, "Time Period must have End Time");
	public static final MarketRuntimeException START_TIME_END_TIME_MUST_HAVE_SAME_TIME_ZONE = new MarketRuntimeException(ExceptionLanguageKeys.START_TIME_END_TIME_MUST_HAVE_SAME_TIME_ZONE, ExceptionType.IllegalArgumentException, "Start Time and End Time must have the same Time Zone in Time Period");
	public static final MarketRuntimeException START_TIME_MUST_HAVE_BE_BEFORE_END_TIME = new MarketRuntimeException(ExceptionLanguageKeys.START_TIME_MUST_HAVE_BE_BEFORE_END_TIME, ExceptionType.IllegalArgumentException, "Start Time must be before End Time in Time Period");
	
	// Time of Day Errors
	public static final MarketRuntimeException TIME_OF_DAY_MUST_HAVE_VALID_HOURS = new MarketRuntimeException(ExceptionLanguageKeys.TIME_OF_DAY_MUST_HAVE_VALID_HOURS, ExceptionType.IllegalArgumentException, "Time of Day must have valid Hours");
	public static final MarketRuntimeException TIME_OF_DAY_MUST_HAVE_VALID_MINUTES = new MarketRuntimeException(ExceptionLanguageKeys.TIME_OF_DAY_MUST_HAVE_VALID_MINUTES, ExceptionType.IllegalArgumentException, "Time of Day must have valid Minutes");
	public static final MarketRuntimeException TIME_OF_DAY_MUST_HAVE_VALID_SECONDS = new MarketRuntimeException(ExceptionLanguageKeys.TIME_OF_DAY_MUST_HAVE_VALID_SECONDS, ExceptionType.IllegalArgumentException, "Time of Day must have valid Seconds");
	public static final MarketRuntimeException TIME_OF_DAY_MUST_HAVE_VALID_TIME_ZONE = new MarketRuntimeException(ExceptionLanguageKeys.TIME_OF_DAY_MUST_HAVE_VALID_TIME_ZONE, ExceptionType.IllegalArgumentException, "Time of Day must have Time Zone");
	
	// Business Calendar Errors
	public static final MarketRuntimeException INVALID_BUSINESS_CALENDAR = new MarketRuntimeException(ExceptionLanguageKeys.INVALID_BUSINESS_CALENDAR, ExceptionType.IllegalArgumentException, "Invalid Business Calendar");
	
	// Audit Trail
	public static final MarketRuntimeException NULL_AUDIT_TRAIL_ENTRY_CANNOT_BE_CREATED = new MarketRuntimeException(ExceptionLanguageKeys.NULL_AUDIT_TRAIL_ENTRY_CANNOT_BE_CREATED, ExceptionType.IllegalArgumentException, "Null Audit Trail Entry cannot be Created");
	public static final MarketRuntimeException AUDIT_TRAIL_MUST_HAVE_DATE = new MarketRuntimeException(ExceptionLanguageKeys.AUDIT_TRAIL_MUST_HAVE_DATE, ExceptionType.IllegalArgumentException, "Audit Trail Entry must have Date");
	public static final MarketRuntimeException AUDIT_TRAIL_MUST_HAVE_ACTION = new MarketRuntimeException(ExceptionLanguageKeys.AUDIT_TRAIL_MUST_HAVE_ACTION, ExceptionType.IllegalArgumentException, "Audit Trail Entry must have Action");
	public static final MarketRuntimeException AUDIT_TRAIL_MUST_HAVE_OBJECT_ID = new MarketRuntimeException(ExceptionLanguageKeys.AUDIT_TRAIL_MUST_HAVE_OBJECT_ID, ExceptionType.IllegalArgumentException, "Audit Trail Entry must have Object ID");
	public static final MarketRuntimeException AUDIT_TRAIL_MUST_HAVE_OBJECT_TYPE = new MarketRuntimeException(ExceptionLanguageKeys.AUDIT_TRAIL_MUST_HAVE_OBJECT_TYPE, ExceptionType.IllegalArgumentException, "Audit Trail Entry must have Object Type");
	public static final MarketRuntimeException AUDIT_TRAIL_MUST_HAVE_USER = new MarketRuntimeException(ExceptionLanguageKeys.AUDIT_TRAIL_MUST_HAVE_USER, ExceptionType.IllegalArgumentException, "Audit Trail Entry must have User");

	// Rollover Errors 
	public static final MarketRuntimeException NON_ROLLABLE_OBJECT_CANNOT_BE_ROLLED_OVER = new MarketRuntimeException(ExceptionLanguageKeys.NON_ROLLABLE_OBJECT_CANNOT_BE_ROLLED_OVER, ExceptionType.IllegalArgumentException, "Object has to be rollable to be rolled over");
	public static final MarketRuntimeException OBJECT_HAS_TO_REMAIN_ROLLABLE = new MarketRuntimeException(ExceptionLanguageKeys.OBJECT_HAS_TO_REMAIN_ROLLABLE, ExceptionType.IllegalArgumentException, "Object has to remain rollable after rollover");
	public static final MarketRuntimeException UNDERLYING_OBJECT_CANNOT_BE_REMOVED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.UNDERLYING_OBJECT_CANNOT_BE_REMOVED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Underlying Object cannot be removed, while the object is rolled over");
	public static final MarketRuntimeException UNDERLYING_OBJECT_CANNOT_BE_ADDED_WHILE_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.UNDERLYING_OBJECT_CANNOT_BE_ADDED_WHILE_ROLLOVER, ExceptionType.IllegalArgumentException, "Underlying Object cannot be added, while the object is rolled over");
	public static final MarketRuntimeException INVALID_UNDELYING_OBJECT_PROVIDED_FOR_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.INVALID_UNDELYING_OBJECT_PROVIDED_FOR_ROLLOVER, ExceptionType.IllegalArgumentException, "Underlying Object provided for the Target Object is not the same as marked on the Target Object itself");
	public static final MarketRuntimeException UNDERLYING_OBJECT_PROVIDED_FOR_ROLLOVER_IS_NOT_ROLLED_FROM_UNDERLYING_OF_SOURCE_OBJECT = new MarketRuntimeException(ExceptionLanguageKeys.UNDERLYING_OBJECT_PROVIDED_FOR_ROLLOVER_IS_NOT_ROLLED_FROM_UNDERLYING_OF_SOURCE_OBJECT, ExceptionType.IllegalArgumentException, "Underlying Object is not rolled from the Underlying Object of the Source Object");
	public static final MarketRuntimeException NON_APPROVED_OBJECT_CANNOT_BE_REFERRED_IN_ROLLOVER = new MarketRuntimeException(ExceptionLanguageKeys.NON_APPROVED_OBJECT_CANNOT_BE_REFERRED_IN_ROLLOVER, ExceptionType.IllegalArgumentException, "Non-Approved Object cannot be part of the Rollover Process");
	public static final MarketRuntimeException ROLLOVER_CANNOT_CHANGE_LIST_OF_ROLLABLE_PROPERTIES = new MarketRuntimeException(ExceptionLanguageKeys.ROLLOVER_CANNOT_CHANGE_LIST_OF_ROLLABLE_PROPERTIES, ExceptionType.IllegalArgumentException, "Rollover cannot change the list of rollable properties");
	public static final MarketRuntimeException ROLLOVER_CANNOT_CHANGE_NUMBER_OF_PROPERTIES = new MarketRuntimeException(ExceptionLanguageKeys.ROLLOVER_CANNOT_CHANGE_NUMBER_OF_PROPERTIES, ExceptionType.IllegalArgumentException, "Rollover cannot change the number of properties");		
	public static final MarketRuntimeException ROLLOVER_CANNOT_ADD_OR_REMOVE_PROPERTIES = new MarketRuntimeException(ExceptionLanguageKeys.ROLLOVER_CANNOT_ADD_OR_REMOVE_PROPERTIES, ExceptionType.IllegalArgumentException, "Rollover cannot add or remove Properties");
	public static final MarketRuntimeException ROLLOVER_CANNOT_CHANGE_NON_ROLLABLE_PROPERTIES = new MarketRuntimeException(ExceptionLanguageKeys.ROLLOVER_CANNOT_CHANGE_NON_ROLLABLE_PROPERTIES, ExceptionType.IllegalArgumentException, "Rollover cannot change Non-Rollable Properties");		
	public static final MarketRuntimeException ROLLED_OBJECTS_HAVE_SAME_CODE = new MarketRuntimeException(ExceptionLanguageKeys.ROLLED_OBJECTS_HAVE_SAME_CODE, ExceptionType.IllegalArgumentException, "Rolled Objects have the same Code, they should be different");		
	public static final MarketRuntimeException ROLLABLE_PROPERTY_MUST_BE_VALID_PROPERTY_ON_OBJECT = new MarketRuntimeException(ExceptionLanguageKeys.ROLLABLE_PROPERTY_MUST_BE_VALID_PROPERTY_ON_OBJECT, ExceptionType.IllegalArgumentException, "Rollable Property must be a valid Property on Object");
	
	// Market Operator Management Errors
	public static final MarketRuntimeException MARKET_OPERATOR_CANNOT_BE_OVERWRITTEN_WITH_AN_OLDER_VERSION = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_OPERATOR_CANNOT_BE_OVERWRITTEN_WITH_AN_OLDER_VERSION, ExceptionType.IllegalArgumentException, "Market Operator cannot be Overwritten with an Older Version of the same Market Operator");
	public static final MarketRuntimeException MARKET_OPERATOR_MUST_HAVE_CODE = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_OPERATOR_MUST_HAVE_CODE, ExceptionType.IllegalArgumentException, "Market Operator must have Code");
	public static final MarketRuntimeException MARKET_OPERATOR_MUST_HAVE_NAME = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_OPERATOR_MUST_HAVE_NAME, ExceptionType.IllegalArgumentException, "Market Operator must have Name");
	public static final MarketRuntimeException MARKET_OPERATOR_MUST_HAVE_DESCRIPTION = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_OPERATOR_MUST_HAVE_DESCRIPTION, ExceptionType.IllegalArgumentException, "Market Operator must have Description");
	public static final MarketRuntimeException MARKET_OPERATOR_MUST_HAVE_BUSINESS_ENTITY = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_OPERATOR_MUST_HAVE_BUSINESS_ENTITY, ExceptionType.IllegalArgumentException, "Market Operator must have Business Entity");
	public static final MarketRuntimeException NEW_MARKET_OPERATOR_MUST_NOT_HAVE_CREATION_AUDIT = new MarketRuntimeException(ExceptionLanguageKeys.NEW_MARKET_OPERATOR_MUST_NOT_HAVE_CREATION_AUDIT, ExceptionType.IllegalArgumentException, "Market Operator must not have Creation Audit");
	public static final MarketRuntimeException NEW_MARKET_OPERATOR_MUST_NOT_HAVE_CHANGE_AUDIT = new MarketRuntimeException(ExceptionLanguageKeys.NEW_MARKET_OPERATOR_MUST_NOT_HAVE_CHANGE_AUDIT, ExceptionType.IllegalArgumentException, "Market Operator must not have Change Audit");
	public static final MarketRuntimeException NEW_MARKET_OPERATOR_MUST_NOT_HAVE_APPROVAL_AUDIT = new MarketRuntimeException(ExceptionLanguageKeys.NEW_MARKET_OPERATOR_MUST_NOT_HAVE_APPROVAL_AUDIT, ExceptionType.IllegalArgumentException, "Market Operator must not have Approval Audit");
	public static final MarketRuntimeException NEW_MARKET_OPERATOR_MUST_NOT_HAVE_SUSPENSION_AUDIT = new MarketRuntimeException(ExceptionLanguageKeys.NEW_MARKET_OPERATOR_MUST_NOT_HAVE_SUSPENSION_AUDIT, ExceptionType.IllegalArgumentException, "Market Operator must not have Suspension Audit");
	public static final MarketRuntimeException NEW_MARKET_OPERATOR_MUST_NOT_HAVE_ACTIVATION_STATUS = new MarketRuntimeException(ExceptionLanguageKeys.NEW_MARKET_OPERATOR_MUST_NOT_HAVE_ACTIVATION_STATUS, ExceptionType.IllegalArgumentException, "Market Operator must not have Activation Status");
	public static final MarketRuntimeException NEW_MARKET_OPERATOR_MUST_NOT_HAVE_MARKET_OPERATOR_AGREEMENT = new MarketRuntimeException(ExceptionLanguageKeys.NEW_MARKET_OPERATOR_MUST_NOT_HAVE_MARKET_OPERATOR_AGREEMENT, ExceptionType.IllegalArgumentException, "Market Operator must not have Market Operator Agreement");
	public static final MarketRuntimeException NULL_MARKET_OPERATOR_CANNOT_BE_CREATED = new MarketRuntimeException(ExceptionLanguageKeys.NULL_MARKET_OPERATOR_CANNOT_BE_CREATED, ExceptionType.IllegalArgumentException, "Null Market Operator cannot be created");	
	public static final MarketRuntimeException MARKET_OPERATOR_MUST_HAVE_OWNER_USER = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_OPERATOR_MUST_HAVE_OWNER_USER, ExceptionType.IllegalArgumentException, "Market Operator must have Owner User");
	public static final MarketRuntimeException MARKET_OPERATOR_CANNOT_BE_CREATED_WITH_NULL_CODE = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_OPERATOR_CANNOT_BE_CREATED_WITH_NULL_CODE, ExceptionType.IllegalArgumentException, "Market Operator cannot be created with a Null Code");
	public static final MarketRuntimeException MARKET_OPERATOR_ALREADY_EXISTS = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_OPERATOR_ALREADY_EXISTS, ExceptionType.IllegalArgumentException, "Market Operator cannot be created, already exists");
	public static final MarketRuntimeException MULTIPLE_MARKET_OPERATORS_RETURNED_FOR_NAME = new MarketRuntimeException(ExceptionLanguageKeys.MULTIPLE_MARKET_OPERATORS_RETURNED_FOR_NAME, ExceptionType.IllegalStateException, "Multiple Market Operator returned for a Name (Primary Key)");
	public static final MarketRuntimeException NON_EXISTENT_MARKET_OPERATOR = new MarketRuntimeException(ExceptionLanguageKeys.NON_EXISTENT_MARKET_OPERATOR, ExceptionType.IllegalArgumentException, "Non-Existent Market Operator");
	public static final MarketRuntimeException MARKET_OPERATOR_CAN_ONLY_BE_APPROVED_IF_UNDERLYING_BUSINESS_ENTITY_IS_APPROVED = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_OPERATOR_CAN_ONLY_BE_APPROVED_IF_UNDERLYING_BUSINESS_ENTITY_IS_APPROVED, ExceptionType.IllegalStateException, "Market Operator can only be approved, if underlying Business Entity is approved");
	public static final MarketRuntimeException MARKET_OPERATOR_CAN_ONLY_BE_APPROVED_IF_OWNER_IS_APPROVED = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_OPERATOR_CAN_ONLY_BE_APPROVED_IF_OWNER_IS_APPROVED, ExceptionType.IllegalStateException, "Market Operator can only be approved, if the Owner is approved");
	public static final MarketRuntimeException MARKET_OPERATOR_THAT_HAS_NO_DEPENDENT_MARKETS_CAN_BE_SUSPENDED = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_OPERATOR_THAT_HAS_NO_DEPENDENT_MARKETS_CAN_BE_SUSPENDED, ExceptionType.IllegalArgumentException, "Only Market Operator that has no dependent Market can be suspended, suspend the dependent Market first");
	public static final MarketRuntimeException MARKET_OPERATOR_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_CHANGED = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_OPERATOR_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_CHANGED, ExceptionType.IllegalStateException, "Market Operator only in Created or Suspended State can be Changed");
	public static final MarketRuntimeException MARKET_OPERATOR_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_DELETED = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_OPERATOR_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_DELETED, ExceptionType.IllegalStateException, "Market Operator only in Created or Suspended State can be Deleted");
	public static final MarketRuntimeException MARKET_OPERATOR_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_APPROVED = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_OPERATOR_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_APPROVED, ExceptionType.IllegalStateException, "Market Operator only in Created or Suspended State can be Approved");
	public static final MarketRuntimeException MARKET_OPERATOR_NOT_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_SUSPENDED = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_OPERATOR_NOT_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_SUSPENDED, ExceptionType.IllegalStateException, "Market Operator NOT in Created or Suspended State can be Suspended");
	public static final MarketRuntimeException MARKET_OPERATOR_THAT_HAS_NO_APPROVED_DEPENDENT_MARKETS_CAN_BE_FORCED_TO_BE_CHANGED = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_OPERATOR_THAT_HAS_NO_APPROVED_DEPENDENT_MARKET_CAN_BE_FORCED_TO_BE_CHANGED, ExceptionType.IllegalArgumentException, "Only Market Operator that has no approved dependent Market can be forced to be changed");
	public static final MarketRuntimeException MARKET_OPERATOR_THAT_HAS_NO_DEPENDENT_MARKET_CAN_BE_DELETED = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_OPERATOR_THAT_HAS_NO_DEPENDENT_MARKET_CAN_BE_DELETED, ExceptionType.IllegalArgumentException, "Only Market Operator that has no dependent Market can be deleted");
	public static final MarketRuntimeException MARKET_OPERATOR_MUST_HAVE_MARKET_OPERATOR_AGREEMENT_DOCUMENT = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_OPERATOR_MUST_HAVE_MARKET_OPERATOR_AGREEMENT_DOCUMENT, ExceptionType.IllegalArgumentException, "Market Operator must have a Market Operator Agreement Document");
	public static final MarketRuntimeException MARKET_OPERATOR_CAN_ONLY_BE_SUSPENDED_IF_DEPENDENT_OBJECTS_ARE_SUSPENDED = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_OPERATOR_CAN_ONLY_BE_SUSPENDED_IF_DEPENDENT_OBJECTS_ARE_SUSPENDED, ExceptionType.IllegalStateException, "Market Operator can only be suspended, if dependent objects are suspended");
	
	// Market Management Errors
	public static final MarketRuntimeException MARKET_CANNOT_BE_OVERWRITTEN_WITH_AN_OLDER_VERSION = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_CANNOT_BE_OVERWRITTEN_WITH_AN_OLDER_VERSION, ExceptionType.IllegalArgumentException, "Market cannot be Overwritten with an Older Version of the same Market");
	public static final MarketRuntimeException NULL_MARKET_CANNOT_BE_CREATED = new MarketRuntimeException(ExceptionLanguageKeys.NULL_MARKET_CANNOT_BE_CREATED, ExceptionType.IllegalArgumentException, "Null Market cannot be created");
	public static final MarketRuntimeException MARKET_CANNOT_BE_CREATED_WITH_NULL_CODE = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_CANNOT_BE_CREATED_WITH_NULL_CODE, ExceptionType.IllegalArgumentException, "Market cannot be created with a Null Code (Primary Key)");
	public static final MarketRuntimeException MARKET_ALREADY_EXISTS = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_ALREADY_EXISTS, ExceptionType.IllegalArgumentException, "Market cannot be created, already exists");
	public static final MarketRuntimeException MULTIPLE_MARKET_RETURNED_FOR_CODE = new MarketRuntimeException(ExceptionLanguageKeys.MULTIPLE_MARKET_RETURNED_FOR_CODE, ExceptionType.IllegalStateException, "Multiple Market returned for a Code (Primary Key)");
	public static final MarketRuntimeException NO_MARKET_RETURNED_FOR_CODE = new MarketRuntimeException(ExceptionLanguageKeys.NO_MARKET_RETURNED_FOR_CODE, ExceptionType.IllegalStateException, "No Market returned for a Code (Primary Key)");
	public static final MarketRuntimeException MARKET_MUST_HAVE_NAME = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_NAME, ExceptionType.IllegalStateException, "Market must have a Name");
	public static final MarketRuntimeException MARKET_MUST_HAVE_DESCRIPTION = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_DESCRIPTION, ExceptionType.IllegalStateException, "Market must have a Description");
	public static final MarketRuntimeException MARKET_MUST_HAVE_CODE = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_CODE, ExceptionType.IllegalArgumentException, "Market must have a Code");
	public static final MarketRuntimeException MARKET_CODE_MUST_BE_MARKET_OPERATOR_CODE_AND_INSTRUMENT_CODE = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_CODE_MUST_BE_MARKET_OPERATOR_CODE_AND_INSTRUMENT_CODE, ExceptionType.IllegalArgumentException, "Market code must be MarketOperatorCodeInstrumentCode");
	public static final MarketRuntimeException MARKET_MUST_HAVE_INSTRUMENT_CODE = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_INSTRUMENT_CODE, ExceptionType.IllegalArgumentException, "Market must have an Instrument Code");
	public static final MarketRuntimeException MARKET_MUST_HAVE_MARKET_OPERATOR_CODE = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_MARKET_OPERATOR_CODE, ExceptionType.IllegalArgumentException, "Market must have a Market Operator Code");
	public static final MarketRuntimeException MARKET_MUST_HAVE_QUOTE_TYPE = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_QUOTE_TYPE, ExceptionType.IllegalArgumentException, "Market must have a Quote Type");
	public static final MarketRuntimeException MARKET_MUST_HAVE_BUSINESS_ENTITY = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_BUSINESS_ENTITY, ExceptionType.IllegalArgumentException, "Market must have a Business Entity");
	public static final MarketRuntimeException MARKET_MUST_HAVE_MINIMUM_CONTRACTS_TRADED = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_MINIMUM_CONTRACTS_TRADED, ExceptionType.IllegalArgumentException, "Market must have Minimun Contracts Traded");
	public static final MarketRuntimeException MARKET_MUST_HAVE_POSITIVE_MAXIMUM_CONTRACTS_TRADED = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_POSITIVE_MAXIMUM_CONTRACTS_TRADED, ExceptionType.IllegalArgumentException, "Market must have positive Maximum Contracts Traded");
	public static final MarketRuntimeException MARKET_MUST_HAVE_MINIMUM_QUOTE_INCREMENT = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_MINIMUM_QUOTE_INCREMENT, ExceptionType.IllegalArgumentException, "Market must have Minimum Quote Increment");
	public static final MarketRuntimeException MARKET_MUST_HAVE_TRADING_SESSION = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_TRADING_SESSION, ExceptionType.IllegalArgumentException, "Market must have a Trading Session");
	public static final MarketRuntimeException MARKET_MUST_HAVE_MARKET_OPERATION_DAYS = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_MARKET_OPERATION_DAYS, ExceptionType.IllegalArgumentException, "Market must have a Market Operation Days");
	public static final MarketRuntimeException MARKET_MUST_HAVE_MARKET_TIMEZONE_ID = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_MARKET_TIMEZONE_ID, ExceptionType.IllegalArgumentException, "Market must have a Valid Market TimeZone ID");
	public static final MarketRuntimeException NON_CONTINUOUS_MARKET_MUST_HAVE_TRADING_HOURS = new MarketRuntimeException(ExceptionLanguageKeys.NON_CONTINUOUS_MARKET_MUST_HAVE_TRADING_HOURS, ExceptionType.IllegalArgumentException, "Non-Continuos Market must have a Trading Hours");
	public static final MarketRuntimeException MARKET_MUST_HAVE_TRADING_DAY_END = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_TRADING_DAY_END, ExceptionType.IllegalArgumentException, "Market must have a Trading Day End");
	public static final MarketRuntimeException CALL_MARKET_MUST_BE_NON_CONTINUOUS = new MarketRuntimeException(ExceptionLanguageKeys.CALL_MARKET_MUST_BE_NON_CONTINUOUS, ExceptionType.IllegalArgumentException, "Call Market must be Non-Continuous Market");
	public static final MarketRuntimeException MARKET_MUST_HAVE_EXECUTION_SYSTEM = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_EXECUTION_SYSTEM, ExceptionType.IllegalArgumentException, "Market must have an Execution System");
	public static final MarketRuntimeException MARKET_MUST_HAVE_SECONDARY_ORDER_PRECEDENCE_RULE = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_SECONDARY_ORDER_PRECEDENCE_RULE, ExceptionType.IllegalArgumentException, "Market must have Secondary Order Precedence Rule");
	public static final MarketRuntimeException MARKET_MUST_HAVE_TIME_PRECEDENCE_AS_SECONDARY_ORDER_PRECEDENCE_RULE = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_TIME_PRECEDENCE_AS_SECONDARY_ORDER_PRECEDENCE_RULE, ExceptionType.IllegalArgumentException, "Market must have Time Precedence as Secondary Order Precedence Rule");
	public static final MarketRuntimeException MARKET_MUST_HAVE_UNRESTRICTED_ORDER_PRECEDENCE_AS_FIRST_SECONDARY_ORDER_PRECEDENCE_RULE_FOR_MARKETS_THAT_ALLOW_ORDER_SIZE_RESTRICTION = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_UNRESTRICTED_ORDER_PRECEDENCE_AS_FIRST_SECONDARY_ORDER_PRECEDENCE_RULE_FOR_MARKETS_THAT_ALLOW_ORDER_SIZE_RESTRICTION, ExceptionType.IllegalArgumentException, "Market must have Unrestricted Order Precedence as First Secondary Order Precedence Rule for Markets, that Allow Order Size Restriction");
	public static final MarketRuntimeException MARKET_MUST_HAVE_EACH_SECONDARY_ORDER_PRECEDENCE_RULE_ONCE = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_EACH_SECONDARY_ORDER_PRECEDENCE_RULE_ONCE, ExceptionType.IllegalArgumentException, "Market must have each Secondary Order Precedence Rule once");
	public static final MarketRuntimeException MARKET_MUST_HAVE_CLEARING_BANK = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_CLEARING_BANK, ExceptionType.IllegalArgumentException, "Market must have Clearing Bank");
	public static final MarketRuntimeException MARKET_MUST_HAVE_COMMISSION = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_COMMISSION, ExceptionType.IllegalArgumentException, "Market must have a Commission");
	public static final MarketRuntimeException MARKET_MUST_HAVE_COMMISSION_CURRENCY = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_COMMISSION_CURRENCY, ExceptionType.IllegalArgumentException, "Market must have a Commission Currency");
	public static final MarketRuntimeException MARKET_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_CHANGED = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_CHANGED, ExceptionType.IllegalStateException, "Market only in Created or Suspended State can be Changed");
	public static final MarketRuntimeException MARKET_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_DELETED = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_DELETED, ExceptionType.IllegalStateException, "Market only in Created or Suspended State can be Deleted");
	public static final MarketRuntimeException ACTIVE_MARKET_CANNOT_BE_SUSPENDED = new MarketRuntimeException(ExceptionLanguageKeys.ACTIVE_MARKET_CANNOT_BE_SUSPENDED, ExceptionType.IllegalStateException, "Active Market cannot be suspended, deactivate it first");
	public static final MarketRuntimeException ACTIVE_MARKET_CANNOT_BE_DELETED = new MarketRuntimeException(ExceptionLanguageKeys.ACTIVE_MARKET_CANNOT_BE_DELETED, ExceptionType.IllegalStateException, "Active Market cannot be deleted, deactivate it first");
	public static final MarketRuntimeException ACTIVE_MARKET_CANNOT_BE_CHANGED = new MarketRuntimeException(ExceptionLanguageKeys.ACTIVE_MARKET_CANNOT_BE_CHANGED, ExceptionType.IllegalStateException, "Active Market cannot be changed, deactivate it first");
	public static final MarketRuntimeException MARKET_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_APPROVED = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_ONLY_IN_CREATED_OR_SUSPEDED_STATE_CAN_BE_APPROVED, ExceptionType.IllegalStateException, "Market only in Created or Suspended State can be Approved");
	public static final MarketRuntimeException MARKET_ONLY_IN_APPROVED_OR_DEACTIVATED_STATE_CAN_BE_SUSPENDED = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_ONLY_IN_APPROVED_OR_DEACTIVATED_STATE_CAN_BE_SUSPENDED, ExceptionType.IllegalStateException, "Market only in Approved or Deactivated State can be Suspended");
	public static final MarketRuntimeException MARKET_CAN_ONLY_BE_APPROVED_IF_UNDERLYING_INSTRUMENT_IS_APPROVED = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_CAN_ONLY_BE_APPROVED_IF_UNDERLYING_INSTRUMENT_IS_APPROVED, ExceptionType.IllegalStateException, "Market can only be approved, if underlying Instrument is approved");
	public static final MarketRuntimeException MARKET_CAN_ONLY_BE_APPROVED_IF_UNDERLYING_MARKET_OPERATOR_IS_APPROVED = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_CAN_ONLY_BE_APPROVED_IF_UNDERLYING_MARKET_OPERATOR_IS_APPROVED, ExceptionType.IllegalStateException, "Market can only be approved, if underlying Market Operator is approved");
	public static final MarketRuntimeException MARKET_CAN_ONLY_BE_APPROVED_IF_UNDERLYING_BUSINESS_ENTITY_IS_APPROVED = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_CAN_ONLY_BE_APPROVED_IF_UNDERLYING_BUSINESS_ENTITY_IS_APPROVED, ExceptionType.IllegalStateException, "Market can only be approved, if underlying Business Entity is approved");
	public static final MarketRuntimeException MARKET_MUST_HAVE_MARKET_OPERATOR_CONTRACT = new MarketRuntimeException(ExceptionLanguageKeys.MARKET_MUST_HAVE_MARKET_OPERATOR_CONTRACT, ExceptionType.IllegalArgumentException, "Market must have a Market Operator Contract");
	public static final MarketRuntimeException NON_ACTIVE_MARKET_CANNOT_BE_DEACTIVATED = new MarketRuntimeException(ExceptionLanguageKeys.NON_ACTIVE_MARKET_CANNOT_BE_DEACTIVATED, ExceptionType.IllegalStateException, "Non-Active Market cannot be deactivated");
	public static final MarketRuntimeException NON_CLOSED_MARKET_CANNOT_BE_DEACTIVATED = new MarketRuntimeException(ExceptionLanguageKeys.NON_CLOSED_MARKET_CANNOT_BE_DEACTIVATED, ExceptionType.IllegalStateException, "Non-Closed Market cannot be deactivated");
	public static final MarketRuntimeException NON_APPROVED_MARKET_CANNOT_BE_ACTIVATED = new MarketRuntimeException(ExceptionLanguageKeys.NON_APPROVED_MARKET_CANNOT_BE_ACTIVATED, ExceptionType.IllegalStateException, "Non-Approved Market cannot be activated");
	public static final MarketRuntimeException ACTIVE_MARKET_CANNOT_BE_ACTIVATED = new MarketRuntimeException(ExceptionLanguageKeys.ACTIVE_MARKET_CANNOT_BE_ACTIVATED, ExceptionType.IllegalStateException, "Active Market cannot be activated");
	public static final MarketRuntimeException CALL_DATE_MUST_BE_IN_FUTURE = new MarketRuntimeException(ExceptionLanguageKeys.CALL_DATE_MUST_BE_IN_FUTURE, ExceptionType.IllegalArgumentException, "Call Date must be in the Future");
	public static final MarketRuntimeException CALL_DATE_MUST_NOT_FURTHER_15_DAYS = new MarketRuntimeException(ExceptionLanguageKeys.CALL_DATE_MUST_NOT_FURTHER_15_DAYS, ExceptionType.IllegalArgumentException, "Call Date must not be further than 15 days in the Future");
	public static final MarketRuntimeException CALL_MARKET_MUST_BE_ACTIVATED_FOR_MARKET_CALL = new MarketRuntimeException(ExceptionLanguageKeys.CALL_MARKET_MUST_BE_ACTIVATED_FOR_MARKET_CALL, ExceptionType.IllegalArgumentException, "Call Market must be activated for Market Call");
	public static final MarketRuntimeException CALL_MARKET_CANNOT_HAVE_CIRCUIT_BREAKER = new MarketRuntimeException(ExceptionLanguageKeys.CALL_MARKET_CANNOT_HAVE_CIRCUIT_BREAKER, ExceptionType.IllegalArgumentException, "Call Market cannot have Circuit Breaker");
	public static final MarketRuntimeException STALE_OBJECT_CANNOT_BE_APPROVED = new MarketRuntimeException(ExceptionLanguageKeys.STALE_OBJECT_CANNOT_BE_APPROVED, ExceptionType.IllegalStateException, "Stale Object cannot be Approved, reload the Object");

	// Circuit Breaker Errors
	public static final MarketRuntimeException CIRCUIT_BREAKER_MUST_HAVE_HALT_RULES_OR_MAX_QUOTE_IMPROVEMENT = new MarketRuntimeException(ExceptionLanguageKeys.CIRCUIT_BREAKER_MUST_HAVE_HALT_RULES_OR_MAX_QUOTE_IMPROVEMENT, ExceptionType.IllegalArgumentException, "Circuit Breaker must have Halt Rules or Max Quote Improvement");
	public static final MarketRuntimeException CIRCUIT_BREAKER_ORDER_REJECT_ACTION_MUST_BE_DEFINED_IF_MAX_QUOTE_IMPROVEMENT_DEFINED = new MarketRuntimeException(ExceptionLanguageKeys.CIRCUIT_BREAKER_ORDER_REJECT_ACTION_MUST_BE_DEFINED_IF_MAX_QUOTE_IMPROVEMENT_DEFINED, ExceptionType.IllegalArgumentException, "Order Reject Action must be defined Max Quote Improvement is defined on Circuit Breaker");
	public static final MarketRuntimeException CIRCUIT_BREAKER_HALT_RULE_MUST_HAVE_QUOTE_CHANGE_AMOUNT = new MarketRuntimeException(ExceptionLanguageKeys.CIRCUIT_BREAKER_HALT_RULE_MUST_HAVE_QUOTE_CHANGE_AMOUNT, ExceptionType.IllegalArgumentException, "Halt Rule must have a Quote Change Amount on Circuit Breaker");
	public static final MarketRuntimeException CIRCUIT_BREAKER_HALT_RULE_MUST_HAVE_QUOTE_CHANGE_TYPE = new MarketRuntimeException(ExceptionLanguageKeys.CIRCUIT_BREAKER_HALT_RULE_MUST_HAVE_QUOTE_CHANGE_TYPE, ExceptionType.IllegalArgumentException, "Halt Rule must have a Quote Change Type on Circuit Breaker");
	
	// Matched Trade Errors
	public static final MarketRuntimeException NULL_TRADE_CANNOT_BE_CREATED = new MarketRuntimeException(ExceptionLanguageKeys.NULL_TRADE_CANNOT_BE_CREATED, ExceptionType.IllegalArgumentException, "Null Trade cannot be created");
	public static final MarketRuntimeException TRADE_ID_MUST_NOT_BE_DEFINED = new MarketRuntimeException(ExceptionLanguageKeys.TRADE_ID_MUST_NOT_BE_DEFINED, ExceptionType.IllegalArgumentException, "Trade ID (Primary Key) must not be defined, it is defined by the system");
	public static final MarketRuntimeException TRADE_ALREADY_EXISTS = new MarketRuntimeException(ExceptionLanguageKeys.TRADE_ALREADY_EXISTS, ExceptionType.IllegalArgumentException, "Trade cannot be created, already exists");
	public static final MarketRuntimeException MULTIPLE_TRADE_RETURNED_FOR_KEY = new MarketRuntimeException(ExceptionLanguageKeys.MULTIPLE_TRADE_RETURNED_FOR_KEY, ExceptionType.IllegalStateException, "Multiple Trade returned for Primary Key");
	public static final MarketRuntimeException MULTIPLE_TRADE_RETURNED_FOR_TRANSACTION_ID = new MarketRuntimeException(ExceptionLanguageKeys.MULTIPLE_TRADE_RETURNED_FOR_TRANSACTION_ID, ExceptionType.IllegalStateException, "Multiple Trade returned for Transaction ID");
	public static final MarketRuntimeException TRADE_CANNOT_BE_CREATED_ON_NON_EXISTENT_MARKET = new MarketRuntimeException(ExceptionLanguageKeys.TRADE_CANNOT_BE_CREATED_ON_NON_EXISTENT_MARKET, ExceptionType.IllegalArgumentException, "Trade cannot be created on a non-existent Market");

	// Properties 
	public static final MarketRuntimeException DUPLICATE_PROPERTY = new MarketRuntimeException(ExceptionLanguageKeys.DUPLICATE_PROPERTY, ExceptionType.IllegalArgumentException, "Duplicate Property Value is set to Property List");
	public static final MarketRuntimeException INVALID_PROPERTY_NAME = new MarketRuntimeException(ExceptionLanguageKeys.INVALID_PROPERTY_NAME, ExceptionType.IllegalArgumentException, "Invalid Property Name is set to Property");
	public static final MarketRuntimeException INVALID_PROPERTY_VALUE = new MarketRuntimeException(ExceptionLanguageKeys.INVALID_PROPERTY_VALUE, ExceptionType.IllegalArgumentException, "Invalid Property Value is set to Property");
	public static final MarketRuntimeException INVALID_PROPERTY_UNIT = new MarketRuntimeException(ExceptionLanguageKeys.INVALID_PROPERTY_UNIT, ExceptionType.IllegalArgumentException, "Invalid Property Unit is set to Property");
	
	/**
	 * Creates Market Runtime Exception 
	 * @param prototype_ Prototype Exception
	 * @param cause_ Cause for this Exception
	 * @param additionalLogInformation_ Additional Log Information
	 * @return Created Runtime Exception
	 */
	public static MarketRuntimeException createExceptionWithDetails(MarketRuntimeException prototype_, Throwable cause_, String additionalLogInformation_) {
		return new MarketRuntimeException(
				prototype_.getLanguageKey(), 
				prototype_.getExceptionType(), 
				prototype_.getMessage() + 
					(additionalLogInformation_ != null || "".equals(additionalLogInformation_) 
					? (": " + additionalLogInformation_)
					: ""), 
				cause_, 
				null);
	
	}
	
	protected MarketRuntimeException(ExceptionMessage message_) {
		super(message_);
	}

	/**
	 * Creates Market Runtime Exception 
	 * @param prototype_ Prototype Exception
	 * @param cause_ Cause for this Exception
	 * @param relatedObjects_ Objects related to this Exception
	 * @return Created Runtime Exception
	 */
	public static MarketRuntimeException createExceptionWithDetails(MarketRuntimeException prototype_, Throwable cause_, Object[] relatedObjects_) {
		return new MarketRuntimeException(
				prototype_.getLanguageKey(), 
				prototype_.getExceptionType(), 
				prototype_.getMessage(),
				null,
				relatedObjects_);
	}
	
	protected MarketRuntimeException(String languageKey_, ExceptionType exceptionType_, String messageInLog_, Throwable cause_, Object[] relatedObjects_) {
		super(languageKey_, exceptionType_, messageInLog_, cause_, relatedObjects_);
	}

	protected MarketRuntimeException(String languageKey_, ExceptionType exceptionType_, String messageInLog_) {
		this(languageKey_, exceptionType_, messageInLog_, null, null);
	}

	@Override
	protected ExceptionMessageType getExceptionMessageType() {
		return ExceptionMessageType.MarketRuntimeException;
	}
}
